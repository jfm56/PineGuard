"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-fetch";
exports.ids = ["vendor-chunks/node-fetch"];
exports.modules = {

/***/ "(rsc)/./node_modules/node-fetch/lib/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/node-fetch/lib/index.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   FetchError: () => (/* binding */ FetchError),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   Request: () => (/* binding */ Request),\n/* harmony export */   Response: () => (/* binding */ Response),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var whatwg_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! whatwg-url */ \"(rsc)/./node_modules/whatwg-url/lib/public-api.js\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zlib */ \"zlib\");\n\n\n\n\n\n\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = stream__WEBPACK_IMPORTED_MODULE_0__.Readable;\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\nclass Blob {\n  constructor() {\n    this[TYPE] = '';\n    const blobParts = arguments[0];\n    const options = arguments[1];\n    const buffers = [];\n    let size = 0;\n    if (blobParts) {\n      const a = blobParts;\n      const length = Number(a.length);\n      for (let i = 0; i < length; i++) {\n        const element = a[i];\n        let buffer;\n        if (element instanceof Buffer) {\n          buffer = element;\n        } else if (ArrayBuffer.isView(element)) {\n          buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n        } else if (element instanceof ArrayBuffer) {\n          buffer = Buffer.from(element);\n        } else if (element instanceof Blob) {\n          buffer = element[BUFFER];\n        } else {\n          buffer = Buffer.from(typeof element === 'string' ? element : String(element));\n        }\n        size += buffer.length;\n        buffers.push(buffer);\n      }\n    }\n    this[BUFFER] = Buffer.concat(buffers);\n    let type = options && options.type !== undefined && String(options.type).toLowerCase();\n    if (type && !/[^\\u0020-\\u007E]/.test(type)) {\n      this[TYPE] = type;\n    }\n  }\n  get size() {\n    return this[BUFFER].length;\n  }\n  get type() {\n    return this[TYPE];\n  }\n  text() {\n    return Promise.resolve(this[BUFFER].toString());\n  }\n  arrayBuffer() {\n    const buf = this[BUFFER];\n    const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n    return Promise.resolve(ab);\n  }\n  stream() {\n    const readable = new Readable();\n    readable._read = function () {};\n    readable.push(this[BUFFER]);\n    readable.push(null);\n    return readable;\n  }\n  toString() {\n    return '[object Blob]';\n  }\n  slice() {\n    const size = this.size;\n    const start = arguments[0];\n    const end = arguments[1];\n    let relativeStart, relativeEnd;\n    if (start === undefined) {\n      relativeStart = 0;\n    } else if (start < 0) {\n      relativeStart = Math.max(size + start, 0);\n    } else {\n      relativeStart = Math.min(start, size);\n    }\n    if (end === undefined) {\n      relativeEnd = size;\n    } else if (end < 0) {\n      relativeEnd = Math.max(size + end, 0);\n    } else {\n      relativeEnd = Math.min(end, size);\n    }\n    const span = Math.max(relativeEnd - relativeStart, 0);\n    const buffer = this[BUFFER];\n    const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n    const blob = new Blob([], {\n      type: arguments[2]\n    });\n    blob[BUFFER] = slicedBuffer;\n    return blob;\n  }\n}\nObject.defineProperties(Blob.prototype, {\n  size: {\n    enumerable: true\n  },\n  type: {\n    enumerable: true\n  },\n  slice: {\n    enumerable: true\n  }\n});\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n  value: 'Blob',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\nlet convert;\ntry {\n  convert = require('encoding').convert;\n} catch (e) {}\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n  var _this = this;\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$size = _ref.size;\n  let size = _ref$size === undefined ? 0 : _ref$size;\n  var _ref$timeout = _ref.timeout;\n  let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n  if (body == null) {\n    // body is undefined or null\n    body = null;\n  } else if (isURLSearchParams(body)) {\n    // body is a URLSearchParams\n    body = Buffer.from(body.toString());\n  } else if (isBlob(body)) ;else if (Buffer.isBuffer(body)) ;else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n    // body is ArrayBuffer\n    body = Buffer.from(body);\n  } else if (ArrayBuffer.isView(body)) {\n    // body is ArrayBufferView\n    body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n  } else if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) ;else {\n    // none of the above\n    // coerce to string then buffer\n    body = Buffer.from(String(body));\n  }\n  this[INTERNALS] = {\n    body,\n    disturbed: false,\n    error: null\n  };\n  this.size = size;\n  this.timeout = timeout;\n  if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) {\n    body.on('error', function (err) {\n      const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n      _this[INTERNALS].error = error;\n    });\n  }\n}\nBody.prototype = {\n  get body() {\n    return this[INTERNALS].body;\n  },\n  get bodyUsed() {\n    return this[INTERNALS].disturbed;\n  },\n  /**\n   * Decode response as ArrayBuffer\n   *\n   * @return  Promise\n   */\n  arrayBuffer() {\n    return consumeBody.call(this).then(function (buf) {\n      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n    });\n  },\n  /**\n   * Return raw response as Blob\n   *\n   * @return Promise\n   */\n  blob() {\n    let ct = this.headers && this.headers.get('content-type') || '';\n    return consumeBody.call(this).then(function (buf) {\n      return Object.assign(\n      // Prevent copying\n      new Blob([], {\n        type: ct.toLowerCase()\n      }), {\n        [BUFFER]: buf\n      });\n    });\n  },\n  /**\n   * Decode response as json\n   *\n   * @return  Promise\n   */\n  json() {\n    var _this2 = this;\n    return consumeBody.call(this).then(function (buffer) {\n      try {\n        return JSON.parse(buffer.toString());\n      } catch (err) {\n        return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n      }\n    });\n  },\n  /**\n   * Decode response as text\n   *\n   * @return  Promise\n   */\n  text() {\n    return consumeBody.call(this).then(function (buffer) {\n      return buffer.toString();\n    });\n  },\n  /**\n   * Decode response as buffer (non-spec api)\n   *\n   * @return  Promise\n   */\n  buffer() {\n    return consumeBody.call(this);\n  },\n  /**\n   * Decode response as text, while automatically detecting the encoding and\n   * trying to decode to UTF-8 (non-spec api)\n   *\n   * @return  Promise\n   */\n  textConverted() {\n    var _this3 = this;\n    return consumeBody.call(this).then(function (buffer) {\n      return convertBody(buffer, _this3.headers);\n    });\n  }\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n  body: {\n    enumerable: true\n  },\n  bodyUsed: {\n    enumerable: true\n  },\n  arrayBuffer: {\n    enumerable: true\n  },\n  blob: {\n    enumerable: true\n  },\n  json: {\n    enumerable: true\n  },\n  text: {\n    enumerable: true\n  }\n});\nBody.mixIn = function (proto) {\n  for (const name of Object.getOwnPropertyNames(Body.prototype)) {\n    // istanbul ignore else: future proof\n    if (!(name in proto)) {\n      const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n      Object.defineProperty(proto, name, desc);\n    }\n  }\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n  var _this4 = this;\n  if (this[INTERNALS].disturbed) {\n    return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n  }\n  this[INTERNALS].disturbed = true;\n  if (this[INTERNALS].error) {\n    return Body.Promise.reject(this[INTERNALS].error);\n  }\n  let body = this.body;\n\n  // body is null\n  if (body === null) {\n    return Body.Promise.resolve(Buffer.alloc(0));\n  }\n\n  // body is blob\n  if (isBlob(body)) {\n    body = body.stream();\n  }\n\n  // body is buffer\n  if (Buffer.isBuffer(body)) {\n    return Body.Promise.resolve(body);\n  }\n\n  // istanbul ignore if: should never happen\n  if (!(body instanceof stream__WEBPACK_IMPORTED_MODULE_0__)) {\n    return Body.Promise.resolve(Buffer.alloc(0));\n  }\n\n  // body is stream\n  // get ready to actually consume the body\n  let accum = [];\n  let accumBytes = 0;\n  let abort = false;\n  return new Body.Promise(function (resolve, reject) {\n    let resTimeout;\n\n    // allow timeout on slow response body\n    if (_this4.timeout) {\n      resTimeout = setTimeout(function () {\n        abort = true;\n        reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n      }, _this4.timeout);\n    }\n\n    // handle stream errors\n    body.on('error', function (err) {\n      if (err.name === 'AbortError') {\n        // if the request was aborted, reject with this Error\n        abort = true;\n        reject(err);\n      } else {\n        // other errors, such as incorrect content-encoding\n        reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n      }\n    });\n    body.on('data', function (chunk) {\n      if (abort || chunk === null) {\n        return;\n      }\n      if (_this4.size && accumBytes + chunk.length > _this4.size) {\n        abort = true;\n        reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n        return;\n      }\n      accumBytes += chunk.length;\n      accum.push(chunk);\n    });\n    body.on('end', function () {\n      if (abort) {\n        return;\n      }\n      clearTimeout(resTimeout);\n      try {\n        resolve(Buffer.concat(accum, accumBytes));\n      } catch (err) {\n        // handle streams that have accumulated too much data (issue #414)\n        reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n      }\n    });\n  });\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n  if (typeof convert !== 'function') {\n    throw new Error('The package `encoding` must be installed to use the textConverted() function');\n  }\n  const ct = headers.get('content-type');\n  let charset = 'utf-8';\n  let res, str;\n\n  // header\n  if (ct) {\n    res = /charset=([^;]*)/i.exec(ct);\n  }\n\n  // no charset in content type, peek at response body for at most 1024 bytes\n  str = buffer.slice(0, 1024).toString();\n\n  // html5\n  if (!res && str) {\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n  }\n\n  // html4\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n    if (!res) {\n      res = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n      if (res) {\n        res.pop(); // drop last quote\n      }\n    }\n\n    if (res) {\n      res = /charset=(.*)/i.exec(res.pop());\n    }\n  }\n\n  // xml\n  if (!res && str) {\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n  }\n\n  // found charset\n  if (res) {\n    charset = res.pop();\n\n    // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n    if (charset === 'gb2312' || charset === 'gbk') {\n      charset = 'gb18030';\n    }\n  }\n\n  // turn raw buffers into a single utf-8 buffer\n  return convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n  // Duck-typing as a necessary condition.\n  if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n    return false;\n  }\n\n  // Brand-checking and more duck-typing as optional condition.\n  return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n  return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n  let p1, p2;\n  let body = instance.body;\n\n  // don't allow cloning a used body\n  if (instance.bodyUsed) {\n    throw new Error('cannot clone body after it is used');\n  }\n\n  // check that body is a stream and not form-data object\n  // note: we can't clone the form-data object without having it as a dependency\n  if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__ && typeof body.getBoundary !== 'function') {\n    // tee instance body\n    p1 = new PassThrough();\n    p2 = new PassThrough();\n    body.pipe(p1);\n    body.pipe(p2);\n    // set instance body to teed body and return the other teed body\n    instance[INTERNALS].body = p1;\n    body = p2;\n  }\n  return body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n  if (body === null) {\n    // body is null\n    return null;\n  } else if (typeof body === 'string') {\n    // body is string\n    return 'text/plain;charset=UTF-8';\n  } else if (isURLSearchParams(body)) {\n    // body is a URLSearchParams\n    return 'application/x-www-form-urlencoded;charset=UTF-8';\n  } else if (isBlob(body)) {\n    // body is blob\n    return body.type || null;\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return null;\n  } else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n    // body is ArrayBuffer\n    return null;\n  } else if (ArrayBuffer.isView(body)) {\n    // body is ArrayBufferView\n    return null;\n  } else if (typeof body.getBoundary === 'function') {\n    // detect form data input from form-data module\n    return `multipart/form-data;boundary=${body.getBoundary()}`;\n  } else if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) {\n    // body is stream\n    // can't really do much about this\n    return null;\n  } else {\n    // Body constructor defaults other things to string\n    return 'text/plain;charset=UTF-8';\n  }\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n  const body = instance.body;\n  if (body === null) {\n    // body is null\n    return 0;\n  } else if (isBlob(body)) {\n    return body.size;\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return body.length;\n  } else if (body && typeof body.getLengthSync === 'function') {\n    // detect form data input from form-data module\n    if (body._lengthRetrievers && body._lengthRetrievers.length == 0 ||\n    // 1.x\n    body.hasKnownLength && body.hasKnownLength()) {\n      // 2.x\n      return body.getLengthSync();\n    }\n    return null;\n  } else {\n    // body is stream\n    return null;\n  }\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n  const body = instance.body;\n  if (body === null) {\n    // body is null\n    dest.end();\n  } else if (isBlob(body)) {\n    body.stream().pipe(dest);\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    dest.write(body);\n    dest.end();\n  } else {\n    // body is stream\n    body.pipe(dest);\n  }\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\nfunction validateName(name) {\n  name = `${name}`;\n  if (invalidTokenRegex.test(name) || name === '') {\n    throw new TypeError(`${name} is not a legal HTTP header name`);\n  }\n}\nfunction validateValue(value) {\n  value = `${value}`;\n  if (invalidHeaderCharRegex.test(value)) {\n    throw new TypeError(`${value} is not a legal HTTP header value`);\n  }\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n  name = name.toLowerCase();\n  for (const key in map) {\n    if (key.toLowerCase() === name) {\n      return key;\n    }\n  }\n  return undefined;\n}\nconst MAP = Symbol('map');\nclass Headers {\n  /**\n   * Headers class\n   *\n   * @param   Object  headers  Response headers\n   * @return  Void\n   */\n  constructor() {\n    let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    this[MAP] = Object.create(null);\n    if (init instanceof Headers) {\n      const rawHeaders = init.raw();\n      const headerNames = Object.keys(rawHeaders);\n      for (const headerName of headerNames) {\n        for (const value of rawHeaders[headerName]) {\n          this.append(headerName, value);\n        }\n      }\n      return;\n    }\n\n    // We don't worry about converting prop to ByteString here as append()\n    // will handle it.\n    if (init == null) ;else if (typeof init === 'object') {\n      const method = init[Symbol.iterator];\n      if (method != null) {\n        if (typeof method !== 'function') {\n          throw new TypeError('Header pairs must be iterable');\n        }\n\n        // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = [];\n        for (const pair of init) {\n          if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n            throw new TypeError('Each header pair must be iterable');\n          }\n          pairs.push(Array.from(pair));\n        }\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new TypeError('Each header pair must be a name/value tuple');\n          }\n          this.append(pair[0], pair[1]);\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (const key of Object.keys(init)) {\n          const value = init[key];\n          this.append(key, value);\n        }\n      }\n    } else {\n      throw new TypeError('Provided initializer must be an object');\n    }\n  }\n\n  /**\n   * Return combined header value given name\n   *\n   * @param   String  name  Header name\n   * @return  Mixed\n   */\n  get(name) {\n    name = `${name}`;\n    validateName(name);\n    const key = find(this[MAP], name);\n    if (key === undefined) {\n      return null;\n    }\n    return this[MAP][key].join(', ');\n  }\n\n  /**\n   * Iterate over all headers\n   *\n   * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n   * @param   Boolean   thisArg   `this` context for callback function\n   * @return  Void\n   */\n  forEach(callback) {\n    let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let pairs = getHeaders(this);\n    let i = 0;\n    while (i < pairs.length) {\n      var _pairs$i = pairs[i];\n      const name = _pairs$i[0],\n        value = _pairs$i[1];\n      callback.call(thisArg, value, name, this);\n      pairs = getHeaders(this);\n      i++;\n    }\n  }\n\n  /**\n   * Overwrite header values given name\n   *\n   * @param   String  name   Header name\n   * @param   String  value  Header value\n   * @return  Void\n   */\n  set(name, value) {\n    name = `${name}`;\n    value = `${value}`;\n    validateName(name);\n    validateValue(value);\n    const key = find(this[MAP], name);\n    this[MAP][key !== undefined ? key : name] = [value];\n  }\n\n  /**\n   * Append a value onto existing header\n   *\n   * @param   String  name   Header name\n   * @param   String  value  Header value\n   * @return  Void\n   */\n  append(name, value) {\n    name = `${name}`;\n    value = `${value}`;\n    validateName(name);\n    validateValue(value);\n    const key = find(this[MAP], name);\n    if (key !== undefined) {\n      this[MAP][key].push(value);\n    } else {\n      this[MAP][name] = [value];\n    }\n  }\n\n  /**\n   * Check for header name existence\n   *\n   * @param   String   name  Header name\n   * @return  Boolean\n   */\n  has(name) {\n    name = `${name}`;\n    validateName(name);\n    return find(this[MAP], name) !== undefined;\n  }\n\n  /**\n   * Delete all header values given name\n   *\n   * @param   String  name  Header name\n   * @return  Void\n   */\n  delete(name) {\n    name = `${name}`;\n    validateName(name);\n    const key = find(this[MAP], name);\n    if (key !== undefined) {\n      delete this[MAP][key];\n    }\n  }\n\n  /**\n   * Return raw headers (non-spec api)\n   *\n   * @return  Object\n   */\n  raw() {\n    return this[MAP];\n  }\n\n  /**\n   * Get an iterator on keys.\n   *\n   * @return  Iterator\n   */\n  keys() {\n    return createHeadersIterator(this, 'key');\n  }\n\n  /**\n   * Get an iterator on values.\n   *\n   * @return  Iterator\n   */\n  values() {\n    return createHeadersIterator(this, 'value');\n  }\n\n  /**\n   * Get an iterator on entries.\n   *\n   * This is the default iterator of the Headers object.\n   *\n   * @return  Iterator\n   */\n  [Symbol.iterator]() {\n    return createHeadersIterator(this, 'key+value');\n  }\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n  value: 'Headers',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nObject.defineProperties(Headers.prototype, {\n  get: {\n    enumerable: true\n  },\n  forEach: {\n    enumerable: true\n  },\n  set: {\n    enumerable: true\n  },\n  append: {\n    enumerable: true\n  },\n  has: {\n    enumerable: true\n  },\n  delete: {\n    enumerable: true\n  },\n  keys: {\n    enumerable: true\n  },\n  values: {\n    enumerable: true\n  },\n  entries: {\n    enumerable: true\n  }\n});\nfunction getHeaders(headers) {\n  let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n  const keys = Object.keys(headers[MAP]).sort();\n  return keys.map(kind === 'key' ? function (k) {\n    return k.toLowerCase();\n  } : kind === 'value' ? function (k) {\n    return headers[MAP][k].join(', ');\n  } : function (k) {\n    return [k.toLowerCase(), headers[MAP][k].join(', ')];\n  });\n}\nconst INTERNAL = Symbol('internal');\nfunction createHeadersIterator(target, kind) {\n  const iterator = Object.create(HeadersIteratorPrototype);\n  iterator[INTERNAL] = {\n    target,\n    kind,\n    index: 0\n  };\n  return iterator;\n}\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n  next() {\n    // istanbul ignore if\n    if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n      throw new TypeError('Value of `this` is not a HeadersIterator');\n    }\n    var _INTERNAL = this[INTERNAL];\n    const target = _INTERNAL.target,\n      kind = _INTERNAL.kind,\n      index = _INTERNAL.index;\n    const values = getHeaders(target, kind);\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    this[INTERNAL].index = index + 1;\n    return {\n      value: values[index],\n      done: false\n    };\n  }\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n  value: 'HeadersIterator',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n  const obj = Object.assign({\n    __proto__: null\n  }, headers[MAP]);\n\n  // http.request() only supports string as Host header. This hack makes\n  // specifying custom Host header possible.\n  const hostHeaderKey = find(headers[MAP], 'Host');\n  if (hostHeaderKey !== undefined) {\n    obj[hostHeaderKey] = obj[hostHeaderKey][0];\n  }\n  return obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n  const headers = new Headers();\n  for (const name of Object.keys(obj)) {\n    if (invalidTokenRegex.test(name)) {\n      continue;\n    }\n    if (Array.isArray(obj[name])) {\n      for (const val of obj[name]) {\n        if (invalidHeaderCharRegex.test(val)) {\n          continue;\n        }\n        if (headers[MAP][name] === undefined) {\n          headers[MAP][name] = [val];\n        } else {\n          headers[MAP][name].push(val);\n        }\n      }\n    } else if (!invalidHeaderCharRegex.test(obj[name])) {\n      headers[MAP][name] = [obj[name]];\n    }\n  }\n  return headers;\n}\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http__WEBPACK_IMPORTED_MODULE_1__.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n  constructor() {\n    let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Body.call(this, body, opts);\n    const status = opts.status || 200;\n    const headers = new Headers(opts.headers);\n    if (body != null && !headers.has('Content-Type')) {\n      const contentType = extractContentType(body);\n      if (contentType) {\n        headers.append('Content-Type', contentType);\n      }\n    }\n    this[INTERNALS$1] = {\n      url: opts.url,\n      status,\n      statusText: opts.statusText || STATUS_CODES[status],\n      headers,\n      counter: opts.counter\n    };\n  }\n  get url() {\n    return this[INTERNALS$1].url || '';\n  }\n  get status() {\n    return this[INTERNALS$1].status;\n  }\n\n  /**\n   * Convenience property representing if the request ended normally\n   */\n  get ok() {\n    return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n  }\n  get redirected() {\n    return this[INTERNALS$1].counter > 0;\n  }\n  get statusText() {\n    return this[INTERNALS$1].statusText;\n  }\n  get headers() {\n    return this[INTERNALS$1].headers;\n  }\n\n  /**\n   * Clone this response\n   *\n   * @return  Response\n   */\n  clone() {\n    return new Response(clone(this), {\n      url: this.url,\n      status: this.status,\n      statusText: this.statusText,\n      headers: this.headers,\n      ok: this.ok,\n      redirected: this.redirected\n    });\n  }\n}\nBody.mixIn(Response.prototype);\nObject.defineProperties(Response.prototype, {\n  url: {\n    enumerable: true\n  },\n  status: {\n    enumerable: true\n  },\n  ok: {\n    enumerable: true\n  },\n  redirected: {\n    enumerable: true\n  },\n  statusText: {\n    enumerable: true\n  },\n  headers: {\n    enumerable: true\n  },\n  clone: {\n    enumerable: true\n  }\n});\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n  value: 'Response',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nconst INTERNALS$2 = Symbol('Request internals');\nconst URL = url__WEBPACK_IMPORTED_MODULE_2__.URL || whatwg_url__WEBPACK_IMPORTED_MODULE_3__.URL;\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = url__WEBPACK_IMPORTED_MODULE_2__.parse;\nconst format_url = url__WEBPACK_IMPORTED_MODULE_2__.format;\n\n/**\n * Wrapper around `new URL` to handle arbitrary URLs\n *\n * @param  {string} urlStr\n * @return {void}\n */\nfunction parseURL(urlStr) {\n  /*\n  \tCheck whether the URL is absolute or not\n  \t\tScheme: https://tools.ietf.org/html/rfc3986#section-3.1\n  \tAbsolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\n  */\n  if (/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.exec(urlStr)) {\n    urlStr = new URL(urlStr).toString();\n  }\n\n  // Fallback to old implementation for arbitrary URLs\n  return parse_url(urlStr);\n}\nconst streamDestructionSupported = (\"destroy\" in stream__WEBPACK_IMPORTED_MODULE_0__.Readable.prototype);\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n  return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\nfunction isAbortSignal(signal) {\n  const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n  return !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n  constructor(input) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let parsedURL;\n\n    // normalize input\n    if (!isRequest(input)) {\n      if (input && input.href) {\n        // in order to support Node.js' Url objects; though WHATWG's URL objects\n        // will fall into this branch also (since their `toString()` will return\n        // `href` property anyway)\n        parsedURL = parseURL(input.href);\n      } else {\n        // coerce input to a string before attempting to parse\n        parsedURL = parseURL(`${input}`);\n      }\n      input = {};\n    } else {\n      parsedURL = parseURL(input.url);\n    }\n    let method = init.method || input.method || 'GET';\n    method = method.toUpperCase();\n    if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n      throw new TypeError('Request with GET/HEAD method cannot have body');\n    }\n    let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n    Body.call(this, inputBody, {\n      timeout: init.timeout || input.timeout || 0,\n      size: init.size || input.size || 0\n    });\n    const headers = new Headers(init.headers || input.headers || {});\n    if (inputBody != null && !headers.has('Content-Type')) {\n      const contentType = extractContentType(inputBody);\n      if (contentType) {\n        headers.append('Content-Type', contentType);\n      }\n    }\n    let signal = isRequest(input) ? input.signal : null;\n    if ('signal' in init) signal = init.signal;\n    if (signal != null && !isAbortSignal(signal)) {\n      throw new TypeError('Expected signal to be an instanceof AbortSignal');\n    }\n    this[INTERNALS$2] = {\n      method,\n      redirect: init.redirect || input.redirect || 'follow',\n      headers,\n      parsedURL,\n      signal\n    };\n\n    // node-fetch-only options\n    this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n    this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n    this.counter = init.counter || input.counter || 0;\n    this.agent = init.agent || input.agent;\n  }\n  get method() {\n    return this[INTERNALS$2].method;\n  }\n  get url() {\n    return format_url(this[INTERNALS$2].parsedURL);\n  }\n  get headers() {\n    return this[INTERNALS$2].headers;\n  }\n  get redirect() {\n    return this[INTERNALS$2].redirect;\n  }\n  get signal() {\n    return this[INTERNALS$2].signal;\n  }\n\n  /**\n   * Clone this request\n   *\n   * @return  Request\n   */\n  clone() {\n    return new Request(this);\n  }\n}\nBody.mixIn(Request.prototype);\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n  value: 'Request',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nObject.defineProperties(Request.prototype, {\n  method: {\n    enumerable: true\n  },\n  url: {\n    enumerable: true\n  },\n  headers: {\n    enumerable: true\n  },\n  redirect: {\n    enumerable: true\n  },\n  clone: {\n    enumerable: true\n  },\n  signal: {\n    enumerable: true\n  }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n  const parsedURL = request[INTERNALS$2].parsedURL;\n  const headers = new Headers(request[INTERNALS$2].headers);\n\n  // fetch step 1.3\n  if (!headers.has('Accept')) {\n    headers.set('Accept', '*/*');\n  }\n\n  // Basic fetch\n  if (!parsedURL.protocol || !parsedURL.hostname) {\n    throw new TypeError('Only absolute URLs are supported');\n  }\n  if (!/^https?:$/.test(parsedURL.protocol)) {\n    throw new TypeError('Only HTTP(S) protocols are supported');\n  }\n  if (request.signal && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable && !streamDestructionSupported) {\n    throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n  }\n\n  // HTTP-network-or-cache fetch steps 2.4-2.7\n  let contentLengthValue = null;\n  if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n    contentLengthValue = '0';\n  }\n  if (request.body != null) {\n    const totalBytes = getTotalBytes(request);\n    if (typeof totalBytes === 'number') {\n      contentLengthValue = String(totalBytes);\n    }\n  }\n  if (contentLengthValue) {\n    headers.set('Content-Length', contentLengthValue);\n  }\n\n  // HTTP-network-or-cache fetch step 2.11\n  if (!headers.has('User-Agent')) {\n    headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n  }\n\n  // HTTP-network-or-cache fetch step 2.15\n  if (request.compress && !headers.has('Accept-Encoding')) {\n    headers.set('Accept-Encoding', 'gzip,deflate');\n  }\n  let agent = request.agent;\n  if (typeof agent === 'function') {\n    agent = agent(parsedURL);\n  }\n\n  // HTTP-network fetch step 4.2\n  // chunked encoding is handled by Node.js\n\n  return Object.assign({}, parsedURL, {\n    method: request.method,\n    headers: exportNodeCompatibleHeaders(headers),\n    agent\n  });\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\nconst URL$1 = url__WEBPACK_IMPORTED_MODULE_2__.URL || whatwg_url__WEBPACK_IMPORTED_MODULE_3__.URL;\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;\nconst isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {\n  const orig = new URL$1(original).hostname;\n  const dest = new URL$1(destination).hostname;\n  return orig === dest || orig[orig.length - dest.length - 1] === '.' && orig.endsWith(dest);\n};\n\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */\nconst isSameProtocol = function isSameProtocol(destination, original) {\n  const orig = new URL$1(original).protocol;\n  const dest = new URL$1(destination).protocol;\n  return orig === dest;\n};\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n  // allow custom promise\n  if (!fetch.Promise) {\n    throw new Error('native promise missing, set fetch.Promise to your favorite alternative');\n  }\n  Body.Promise = fetch.Promise;\n\n  // wrap http.request into fetch\n  return new fetch.Promise(function (resolve, reject) {\n    // build request object\n    const request = new Request(url, opts);\n    const options = getNodeRequestOptions(request);\n    const send = (options.protocol === 'https:' ? https__WEBPACK_IMPORTED_MODULE_4__ : http__WEBPACK_IMPORTED_MODULE_1__).request;\n    const signal = request.signal;\n    let response = null;\n    const abort = function abort() {\n      let error = new AbortError('The user aborted a request.');\n      reject(error);\n      if (request.body && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable) {\n        destroyStream(request.body, error);\n      }\n      if (!response || !response.body) return;\n      response.body.emit('error', error);\n    };\n    if (signal && signal.aborted) {\n      abort();\n      return;\n    }\n    const abortAndFinalize = function abortAndFinalize() {\n      abort();\n      finalize();\n    };\n\n    // send request\n    const req = send(options);\n    let reqTimeout;\n    if (signal) {\n      signal.addEventListener('abort', abortAndFinalize);\n    }\n    function finalize() {\n      req.abort();\n      if (signal) signal.removeEventListener('abort', abortAndFinalize);\n      clearTimeout(reqTimeout);\n    }\n    if (request.timeout) {\n      req.once('socket', function (socket) {\n        reqTimeout = setTimeout(function () {\n          reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n          finalize();\n        }, request.timeout);\n      });\n    }\n    req.on('error', function (err) {\n      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n      if (response && response.body) {\n        destroyStream(response.body, err);\n      }\n      finalize();\n    });\n    fixResponseChunkedTransferBadEnding(req, function (err) {\n      if (signal && signal.aborted) {\n        return;\n      }\n      if (response && response.body) {\n        destroyStream(response.body, err);\n      }\n    });\n\n    /* c8 ignore next 18 */\n    if (parseInt(process.version.substring(1)) < 14) {\n      // Before Node.js 14, pipeline() does not fully support async iterators and does not always\n      // properly handle when the socket close/end events are out of order.\n      req.on('socket', function (s) {\n        s.addListener('close', function (hadError) {\n          // if a data listener is still present we didn't end cleanly\n          const hasDataListener = s.listenerCount('data') > 0;\n\n          // if end happened before close but the socket didn't emit an error, do it now\n          if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {\n            const err = new Error('Premature close');\n            err.code = 'ERR_STREAM_PREMATURE_CLOSE';\n            response.body.emit('error', err);\n          }\n        });\n      });\n    }\n    req.on('response', function (res) {\n      clearTimeout(reqTimeout);\n      const headers = createHeadersLenient(res.headers);\n\n      // HTTP fetch step 5\n      if (fetch.isRedirect(res.statusCode)) {\n        // HTTP fetch step 5.2\n        const location = headers.get('Location');\n\n        // HTTP fetch step 5.3\n        let locationURL = null;\n        try {\n          locationURL = location === null ? null : new URL$1(location, request.url).toString();\n        } catch (err) {\n          // error here can only be invalid URL in Location: header\n          // do not throw when options.redirect == manual\n          // let the user extract the errorneous redirect URL\n          if (request.redirect !== 'manual') {\n            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));\n            finalize();\n            return;\n          }\n        }\n\n        // HTTP fetch step 5.5\n        switch (request.redirect) {\n          case 'error':\n            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n            finalize();\n            return;\n          case 'manual':\n            // node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n            if (locationURL !== null) {\n              // handle corrupted header\n              try {\n                headers.set('Location', locationURL);\n              } catch (err) {\n                // istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n                reject(err);\n              }\n            }\n            break;\n          case 'follow':\n            // HTTP-redirect fetch step 2\n            if (locationURL === null) {\n              break;\n            }\n\n            // HTTP-redirect fetch step 5\n            if (request.counter >= request.follow) {\n              reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n              finalize();\n              return;\n            }\n\n            // HTTP-redirect fetch step 6 (counter increment)\n            // Create a new Request object.\n            const requestOpts = {\n              headers: new Headers(request.headers),\n              follow: request.follow,\n              counter: request.counter + 1,\n              agent: request.agent,\n              compress: request.compress,\n              method: request.method,\n              body: request.body,\n              signal: request.signal,\n              timeout: request.timeout,\n              size: request.size\n            };\n            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n              for (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {\n                requestOpts.headers.delete(name);\n              }\n            }\n\n            // HTTP-redirect fetch step 9\n            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n              reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n              finalize();\n              return;\n            }\n\n            // HTTP-redirect fetch step 11\n            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n              requestOpts.method = 'GET';\n              requestOpts.body = undefined;\n              requestOpts.headers.delete('content-length');\n            }\n\n            // HTTP-redirect fetch step 15\n            resolve(fetch(new Request(locationURL, requestOpts)));\n            finalize();\n            return;\n        }\n      }\n\n      // prepare response\n      res.once('end', function () {\n        if (signal) signal.removeEventListener('abort', abortAndFinalize);\n      });\n      let body = res.pipe(new PassThrough$1());\n      const response_options = {\n        url: request.url,\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: headers,\n        size: request.size,\n        timeout: request.timeout,\n        counter: request.counter\n      };\n\n      // HTTP-network fetch step 12.1.1.3\n      const codings = headers.get('Content-Encoding');\n\n      // HTTP-network fetch step 12.1.1.4: handle content codings\n\n      // in following scenarios we ignore compression support\n      // 1. compression support is disabled\n      // 2. HEAD request\n      // 3. no Content-Encoding header\n      // 4. no content response (204)\n      // 5. content not modified response (304)\n      if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n        response = new Response(body, response_options);\n        resolve(response);\n        return;\n      }\n\n      // For Node v6+\n      // Be less strict when decoding compressed responses, since sometimes\n      // servers send slightly invalid responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n      const zlibOptions = {\n        flush: zlib__WEBPACK_IMPORTED_MODULE_5__.Z_SYNC_FLUSH,\n        finishFlush: zlib__WEBPACK_IMPORTED_MODULE_5__.Z_SYNC_FLUSH\n      };\n\n      // for gzip\n      if (codings == 'gzip' || codings == 'x-gzip') {\n        body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createGunzip(zlibOptions));\n        response = new Response(body, response_options);\n        resolve(response);\n        return;\n      }\n\n      // for deflate\n      if (codings == 'deflate' || codings == 'x-deflate') {\n        // handle the infamous raw deflate response from old servers\n        // a hack for old IIS and Apache servers\n        const raw = res.pipe(new PassThrough$1());\n        raw.once('data', function (chunk) {\n          // see http://stackoverflow.com/questions/37519828\n          if ((chunk[0] & 0x0F) === 0x08) {\n            body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createInflate());\n          } else {\n            body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createInflateRaw());\n          }\n          response = new Response(body, response_options);\n          resolve(response);\n        });\n        raw.on('end', function () {\n          // some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.\n          if (!response) {\n            response = new Response(body, response_options);\n            resolve(response);\n          }\n        });\n        return;\n      }\n\n      // for br\n      if (codings == 'br' && typeof zlib__WEBPACK_IMPORTED_MODULE_5__.createBrotliDecompress === 'function') {\n        body = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_5__.createBrotliDecompress());\n        response = new Response(body, response_options);\n        resolve(response);\n        return;\n      }\n\n      // otherwise, use response as-is\n      response = new Response(body, response_options);\n      resolve(response);\n    });\n    writeToStream(req, request);\n  });\n}\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n  let socket;\n  request.on('socket', function (s) {\n    socket = s;\n  });\n  request.on('response', function (response) {\n    const headers = response.headers;\n    if (headers['transfer-encoding'] === 'chunked' && !headers['content-length']) {\n      response.once('close', function (hadError) {\n        // tests for socket presence, as in some situations the\n        // the 'socket' event is not triggered for the request\n        // (happens in deno), avoids `TypeError`\n        // if a data listener is still present we didn't end cleanly\n        const hasDataListener = socket && socket.listenerCount('data') > 0;\n        if (hasDataListener && !hadError) {\n          const err = new Error('Premature close');\n          err.code = 'ERR_STREAM_PREMATURE_CLOSE';\n          errorCallback(err);\n        }\n      });\n    }\n  });\n}\nfunction destroyStream(stream, err) {\n  if (stream.destroy) {\n    stream.destroy(err);\n  } else {\n    // node < 8\n    stream.emit('error', err);\n    stream.end();\n  }\n}\n\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n  return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fetch);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUE0QjtBQUNKO0FBQ0Y7QUFDYTtBQUNUO0FBQ0Y7O0FBRXhCOztBQUVBO0FBQ0EsTUFBTU0sUUFBUSxHQUFHTiw0Q0FBZTtBQUVoQyxNQUFNTyxNQUFNLEdBQUdDLE1BQU0sQ0FBQyxRQUFRLENBQUM7QUFDL0IsTUFBTUMsSUFBSSxHQUFHRCxNQUFNLENBQUMsTUFBTSxDQUFDO0FBRTNCLE1BQU1FLElBQUksQ0FBQztFQUNWQyxXQUFXQSxDQUFBLEVBQUc7SUFDYixJQUFJLENBQUNGLElBQUksQ0FBQyxHQUFHLEVBQUU7SUFFZixNQUFNRyxTQUFTLEdBQUdDLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFDOUIsTUFBTUMsT0FBTyxHQUFHRCxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBRTVCLE1BQU1FLE9BQU8sR0FBRyxFQUFFO0lBQ2xCLElBQUlDLElBQUksR0FBRyxDQUFDO0lBRVosSUFBSUosU0FBUyxFQUFFO01BQ2QsTUFBTUssQ0FBQyxHQUFHTCxTQUFTO01BQ25CLE1BQU1NLE1BQU0sR0FBR0MsTUFBTSxDQUFDRixDQUFDLENBQUNDLE1BQU0sQ0FBQztNQUMvQixLQUFLLElBQUlFLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR0YsTUFBTSxFQUFFRSxDQUFDLEVBQUUsRUFBRTtRQUNoQyxNQUFNQyxPQUFPLEdBQUdKLENBQUMsQ0FBQ0csQ0FBQyxDQUFDO1FBQ3BCLElBQUlFLE1BQU07UUFDVixJQUFJRCxPQUFPLFlBQVlFLE1BQU0sRUFBRTtVQUM5QkQsTUFBTSxHQUFHRCxPQUFPO1FBQ2pCLENBQUMsTUFBTSxJQUFJRyxXQUFXLENBQUNDLE1BQU0sQ0FBQ0osT0FBTyxDQUFDLEVBQUU7VUFDdkNDLE1BQU0sR0FBR0MsTUFBTSxDQUFDRyxJQUFJLENBQUNMLE9BQU8sQ0FBQ0MsTUFBTSxFQUFFRCxPQUFPLENBQUNNLFVB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QUFJLEdBQUcsNEJBQTRCO1VBQ3ZDdU4sYUFBYSxDQUFDaE0sR0FBRyxDQUFDO1FBQ25CO01BQ0QsQ0FBQyxDQUFDO0lBQ0g7RUFDRCxDQUFDLENBQUM7QUFDSDtBQUVBLFNBQVMySixhQUFhQSxDQUFDN00sTUFBTSxFQUFFa0QsR0FBRyxFQUFFO0VBQ25DLElBQUlsRCxNQUFNLENBQUNtUCxPQUFPLEVBQUU7SUFDbkJuUCxNQUFNLENBQUNtUCxPQUFPLENBQUNqTSxHQUFHLENBQUM7RUFDcEIsQ0FBQyxNQUFNO0lBQ047SUFDQWxELE1BQU0sQ0FBQzhNLElBQUksQ0FBQyxPQUFPLEVBQUU1SixHQUFHLENBQUM7SUFDekJsRCxNQUFNLENBQUNJLEdBQUcsQ0FBQyxDQUFDO0VBQ2I7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQXNNLEtBQUssQ0FBQ3dCLFVBQVUsR0FBRyxVQUFVdk0sSUFBSSxFQUFFO0VBQ2xDLE9BQU9BLElBQUksS0FBSyxHQUFHLElBQUlBLElBQUksS0FBSyxHQUFHLElBQUlBLElBQUksS0FBSyxHQUFHLElBQUlBLElBQUksS0FBSyxHQUFHLElBQUlBLElBQUksS0FBSyxHQUFHO0FBQ3BGLENBQUM7O0FBRUQ7QUFDQStLLEtBQUssQ0FBQ2pOLE9BQU8sR0FBR21ILE1BQU0sQ0FBQ25ILE9BQU87QUFFOUIsaUVBQWVpTixLQUFLLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9waW5lbGFuZHMtd2lsZGZpcmUtYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gvbGliL2luZGV4Lm1qcz80MGE2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTdHJlYW0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCBodHRwIGZyb20gJ2h0dHAnO1xuaW1wb3J0IFVybCBmcm9tICd1cmwnO1xuaW1wb3J0IHdoYXR3Z1VybCBmcm9tICd3aGF0d2ctdXJsJztcbmltcG9ydCBodHRwcyBmcm9tICdodHRwcyc7XG5pbXBvcnQgemxpYiBmcm9tICd6bGliJztcblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3RtcHZhci9qc2RvbS9ibG9iL2FhODViMmFiZjA3NzY2ZmY3YmY1YzFmNmRhYWZiMzcyNmYyZjJkYjUvbGliL2pzZG9tL2xpdmluZy9ibG9iLmpzXG5cbi8vIGZpeCBmb3IgXCJSZWFkYWJsZVwiIGlzbid0IGEgbmFtZWQgZXhwb3J0IGlzc3VlXG5jb25zdCBSZWFkYWJsZSA9IFN0cmVhbS5SZWFkYWJsZTtcblxuY29uc3QgQlVGRkVSID0gU3ltYm9sKCdidWZmZXInKTtcbmNvbnN0IFRZUEUgPSBTeW1ib2woJ3R5cGUnKTtcblxuY2xhc3MgQmxvYiB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXNbVFlQRV0gPSAnJztcblxuXHRcdGNvbnN0IGJsb2JQYXJ0cyA9IGFyZ3VtZW50c1swXTtcblx0XHRjb25zdCBvcHRpb25zID0gYXJndW1lbnRzWzFdO1xuXG5cdFx0Y29uc3QgYnVmZmVycyA9IFtdO1xuXHRcdGxldCBzaXplID0gMDtcblxuXHRcdGlmIChibG9iUGFydHMpIHtcblx0XHRcdGNvbnN0IGEgPSBibG9iUGFydHM7XG5cdFx0XHRjb25zdCBsZW5ndGggPSBOdW1iZXIoYS5sZW5ndGgpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBlbGVtZW50ID0gYVtpXTtcblx0XHRcdFx0bGV0IGJ1ZmZlcjtcblx0XHRcdFx0aWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBCdWZmZXIpIHtcblx0XHRcdFx0XHRidWZmZXIgPSBlbGVtZW50O1xuXHRcdFx0XHR9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhlbGVtZW50KSkge1xuXHRcdFx0XHRcdGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGVsZW1lbnQuYnVmZmVyLCBlbGVtZW50LmJ5dGVPZmZzZXQsIGVsZW1lbnQuYnl0ZUxlbmd0aCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdFx0XHRcdFx0YnVmZmVyID0gQnVmZmVyLmZyb20oZWxlbWVudCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEJsb2IpIHtcblx0XHRcdFx0XHRidWZmZXIgPSBlbGVtZW50W0JVRkZFUl07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YnVmZmVyID0gQnVmZmVyLmZyb20odHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnID8gZWxlbWVudCA6IFN0cmluZyhlbGVtZW50KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2l6ZSArPSBidWZmZXIubGVuZ3RoO1xuXHRcdFx0XHRidWZmZXJzLnB1c2goYnVmZmVyKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzW0JVRkZFUl0gPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpO1xuXG5cdFx0bGV0IHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMudHlwZSAhPT0gdW5kZWZpbmVkICYmIFN0cmluZyhvcHRpb25zLnR5cGUpLnRvTG93ZXJDYXNlKCk7XG5cdFx0aWYgKHR5cGUgJiYgIS9bXlxcdTAwMjAtXFx1MDA3RV0vLnRlc3QodHlwZSkpIHtcblx0XHRcdHRoaXNbVFlQRV0gPSB0eXBlO1xuXHRcdH1cblx0fVxuXHRnZXQgc2l6ZSgpIHtcblx0XHRyZXR1cm4gdGhpc1tCVUZGRVJdLmxlbmd0aDtcblx0fVxuXHRnZXQgdHlwZSgpIHtcblx0XHRyZXR1cm4gdGhpc1tUWVBFXTtcblx0fVxuXHR0ZXh0KCkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpc1tCVUZGRVJdLnRvU3RyaW5nKCkpO1xuXHR9XG5cdGFycmF5QnVmZmVyKCkge1xuXHRcdGNvbnN0IGJ1ZiA9IHRoaXNbQlVGRkVSXTtcblx0XHRjb25zdCBhYiA9IGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGgpO1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoYWIpO1xuXHR9XG5cdHN0cmVhbSgpIHtcblx0XHRjb25zdCByZWFkYWJsZSA9IG5ldyBSZWFkYWJsZSgpO1xuXHRcdHJlYWRhYmxlLl9yZWFkID0gZnVuY3Rpb24gKCkge307XG5cdFx0cmVhZGFibGUucHVzaCh0aGlzW0JVRkZFUl0pO1xuXHRcdHJlYWRhYmxlLnB1c2gobnVsbCk7XG5cdFx0cmV0dXJuIHJlYWRhYmxlO1xuXHR9XG5cdHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiAnW29iamVjdCBCbG9iXSc7XG5cdH1cblx0c2xpY2UoKSB7XG5cdFx0Y29uc3Qgc2l6ZSA9IHRoaXMuc2l6ZTtcblxuXHRcdGNvbnN0IHN0YXJ0ID0gYXJndW1lbnRzWzBdO1xuXHRcdGNvbnN0IGVuZCA9IGFyZ3VtZW50c1sxXTtcblx0XHRsZXQgcmVsYXRpdmVTdGFydCwgcmVsYXRpdmVFbmQ7XG5cdFx0aWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJlbGF0aXZlU3RhcnQgPSAwO1xuXHRcdH0gZWxzZSBpZiAoc3RhcnQgPCAwKSB7XG5cdFx0XHRyZWxhdGl2ZVN0YXJ0ID0gTWF0aC5tYXgoc2l6ZSArIHN0YXJ0LCAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVsYXRpdmVTdGFydCA9IE1hdGgubWluKHN0YXJ0LCBzaXplKTtcblx0XHR9XG5cdFx0aWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZWxhdGl2ZUVuZCA9IHNpemU7XG5cdFx0fSBlbHNlIGlmIChlbmQgPCAwKSB7XG5cdFx0XHRyZWxhdGl2ZUVuZCA9IE1hdGgubWF4KHNpemUgKyBlbmQsIDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZWxhdGl2ZUVuZCA9IE1hdGgubWluKGVuZCwgc2l6ZSk7XG5cdFx0fVxuXHRcdGNvbnN0IHNwYW4gPSBNYXRoLm1heChyZWxhdGl2ZUVuZCAtIHJlbGF0aXZlU3RhcnQsIDApO1xuXG5cdFx0Y29uc3QgYnVmZmVyID0gdGhpc1tCVUZGRVJdO1xuXHRcdGNvbnN0IHNsaWNlZEJ1ZmZlciA9IGJ1ZmZlci5zbGljZShyZWxhdGl2ZVN0YXJ0LCByZWxhdGl2ZVN0YXJ0ICsgc3Bhbik7XG5cdFx0Y29uc3QgYmxvYiA9IG5ldyBCbG9iKFtdLCB7IHR5cGU6IGFyZ3VtZW50c1syXSB9KTtcblx0XHRibG9iW0JVRkZFUl0gPSBzbGljZWRCdWZmZXI7XG5cdFx0cmV0dXJuIGJsb2I7XG5cdH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQmxvYi5wcm90b3R5cGUsIHtcblx0c2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHR5cGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRzbGljZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmxvYi5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuXHR2YWx1ZTogJ0Jsb2InLFxuXHR3cml0YWJsZTogZmFsc2UsXG5cdGVudW1lcmFibGU6IGZhbHNlLFxuXHRjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIGZldGNoLWVycm9yLmpzXG4gKlxuICogRmV0Y2hFcnJvciBpbnRlcmZhY2UgZm9yIG9wZXJhdGlvbmFsIGVycm9yc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIEZldGNoRXJyb3IgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gICBTdHJpbmcgICAgICBtZXNzYWdlICAgICAgRXJyb3IgbWVzc2FnZSBmb3IgaHVtYW5cbiAqIEBwYXJhbSAgIFN0cmluZyAgICAgIHR5cGUgICAgICAgICBFcnJvciB0eXBlIGZvciBtYWNoaW5lXG4gKiBAcGFyYW0gICBTdHJpbmcgICAgICBzeXN0ZW1FcnJvciAgRm9yIE5vZGUuanMgc3lzdGVtIGVycm9yXG4gKiBAcmV0dXJuICBGZXRjaEVycm9yXG4gKi9cbmZ1bmN0aW9uIEZldGNoRXJyb3IobWVzc2FnZSwgdHlwZSwgc3lzdGVtRXJyb3IpIHtcbiAgRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gIC8vIHdoZW4gZXJyLnR5cGUgaXMgYHN5c3RlbWAsIGVyci5jb2RlIGNvbnRhaW5zIHN5c3RlbSBlcnJvciBjb2RlXG4gIGlmIChzeXN0ZW1FcnJvcikge1xuICAgIHRoaXMuY29kZSA9IHRoaXMuZXJybm8gPSBzeXN0ZW1FcnJvci5jb2RlO1xuICB9XG5cbiAgLy8gaGlkZSBjdXN0b20gZXJyb3IgaW1wbGVtZW50YXRpb24gZGV0YWlscyBmcm9tIGVuZC11c2Vyc1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbn1cblxuRmV0Y2hFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5GZXRjaEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZldGNoRXJyb3I7XG5GZXRjaEVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0ZldGNoRXJyb3InO1xuXG5sZXQgY29udmVydDtcbnRyeSB7XG5cdGNvbnZlcnQgPSByZXF1aXJlKCdlbmNvZGluZycpLmNvbnZlcnQ7XG59IGNhdGNoIChlKSB7fVxuXG5jb25zdCBJTlRFUk5BTFMgPSBTeW1ib2woJ0JvZHkgaW50ZXJuYWxzJyk7XG5cbi8vIGZpeCBhbiBpc3N1ZSB3aGVyZSBcIlBhc3NUaHJvdWdoXCIgaXNuJ3QgYSBuYW1lZCBleHBvcnQgZm9yIG5vZGUgPDEwXG5jb25zdCBQYXNzVGhyb3VnaCA9IFN0cmVhbS5QYXNzVGhyb3VnaDtcblxuLyoqXG4gKiBCb2R5IG1peGluXG4gKlxuICogUmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keVxuICpcbiAqIEBwYXJhbSAgIFN0cmVhbSAgYm9keSAgUmVhZGFibGUgc3RyZWFtXG4gKiBAcGFyYW0gICBPYmplY3QgIG9wdHMgIFJlc3BvbnNlIG9wdGlvbnNcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuZnVuY3Rpb24gQm9keShib2R5KSB7XG5cdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0dmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuXHQgICAgX3JlZiRzaXplID0gX3JlZi5zaXplO1xuXG5cdGxldCBzaXplID0gX3JlZiRzaXplID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiRzaXplO1xuXHR2YXIgX3JlZiR0aW1lb3V0ID0gX3JlZi50aW1lb3V0O1xuXHRsZXQgdGltZW91dCA9IF9yZWYkdGltZW91dCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkdGltZW91dDtcblxuXHRpZiAoYm9keSA9PSBudWxsKSB7XG5cdFx0Ly8gYm9keSBpcyB1bmRlZmluZWQgb3IgbnVsbFxuXHRcdGJvZHkgPSBudWxsO1xuXHR9IGVsc2UgaWYgKGlzVVJMU2VhcmNoUGFyYW1zKGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBhIFVSTFNlYXJjaFBhcmFtc1xuXHRcdGJvZHkgPSBCdWZmZXIuZnJvbShib2R5LnRvU3RyaW5nKCkpO1xuXHR9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkgOyBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYm9keSkpIDsgZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG5cdFx0Ly8gYm9keSBpcyBBcnJheUJ1ZmZlclxuXHRcdGJvZHkgPSBCdWZmZXIuZnJvbShib2R5KTtcblx0fSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkpIHtcblx0XHQvLyBib2R5IGlzIEFycmF5QnVmZmVyVmlld1xuXHRcdGJvZHkgPSBCdWZmZXIuZnJvbShib2R5LmJ1ZmZlciwgYm9keS5ieXRlT2Zmc2V0LCBib2R5LmJ5dGVMZW5ndGgpO1xuXHR9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIDsgZWxzZSB7XG5cdFx0Ly8gbm9uZSBvZiB0aGUgYWJvdmVcblx0XHQvLyBjb2VyY2UgdG8gc3RyaW5nIHRoZW4gYnVmZmVyXG5cdFx0Ym9keSA9IEJ1ZmZlci5mcm9tKFN0cmluZyhib2R5KSk7XG5cdH1cblx0dGhpc1tJTlRFUk5BTFNdID0ge1xuXHRcdGJvZHksXG5cdFx0ZGlzdHVyYmVkOiBmYWxzZSxcblx0XHRlcnJvcjogbnVsbFxuXHR9O1xuXHR0aGlzLnNpemUgPSBzaXplO1xuXHR0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuXG5cdGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtKSB7XG5cdFx0Ym9keS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRjb25zdCBlcnJvciA9IGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicgPyBlcnIgOiBuZXcgRmV0Y2hFcnJvcihgSW52YWxpZCByZXNwb25zZSBib2R5IHdoaWxlIHRyeWluZyB0byBmZXRjaCAke190aGlzLnVybH06ICR7ZXJyLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycik7XG5cdFx0XHRfdGhpc1tJTlRFUk5BTFNdLmVycm9yID0gZXJyb3I7XG5cdFx0fSk7XG5cdH1cbn1cblxuQm9keS5wcm90b3R5cGUgPSB7XG5cdGdldCBib2R5KCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMU10uYm9keTtcblx0fSxcblxuXHRnZXQgYm9keVVzZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5kaXN0dXJiZWQ7XG5cdH0sXG5cblx0LyoqXG4gICogRGVjb2RlIHJlc3BvbnNlIGFzIEFycmF5QnVmZmVyXG4gICpcbiAgKiBAcmV0dXJuICBQcm9taXNlXG4gICovXG5cdGFycmF5QnVmZmVyKCkge1xuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gKGJ1Zikge1xuXHRcdFx0cmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGgpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuICAqIFJldHVybiByYXcgcmVzcG9uc2UgYXMgQmxvYlxuICAqXG4gICogQHJldHVybiBQcm9taXNlXG4gICovXG5cdGJsb2IoKSB7XG5cdFx0bGV0IGN0ID0gdGhpcy5oZWFkZXJzICYmIHRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnO1xuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gKGJ1Zikge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24oXG5cdFx0XHQvLyBQcmV2ZW50IGNvcHlpbmdcblx0XHRcdG5ldyBCbG9iKFtdLCB7XG5cdFx0XHRcdHR5cGU6IGN0LnRvTG93ZXJDYXNlKClcblx0XHRcdH0pLCB7XG5cdFx0XHRcdFtCVUZGRVJdOiBidWZcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuICAqIERlY29kZSByZXNwb25zZSBhcyBqc29uXG4gICpcbiAgKiBAcmV0dXJuICBQcm9taXNlXG4gICovXG5cdGpzb24oKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cblx0XHRyZXR1cm4gY29uc3VtZUJvZHkuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uIChidWZmZXIpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKGJ1ZmZlci50b1N0cmluZygpKTtcblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRyZXR1cm4gQm9keS5Qcm9taXNlLnJlamVjdChuZXcgRmV0Y2hFcnJvcihgaW52YWxpZCBqc29uIHJlc3BvbnNlIGJvZHkgYXQgJHtfdGhpczIudXJsfSByZWFzb246ICR7ZXJyLm1lc3NhZ2V9YCwgJ2ludmFsaWQtanNvbicpKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHQvKipcbiAgKiBEZWNvZGUgcmVzcG9uc2UgYXMgdGV4dFxuICAqXG4gICogQHJldHVybiAgUHJvbWlzZVxuICAqL1xuXHR0ZXh0KCkge1xuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHRcdFx0cmV0dXJuIGJ1ZmZlci50b1N0cmluZygpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuICAqIERlY29kZSByZXNwb25zZSBhcyBidWZmZXIgKG5vbi1zcGVjIGFwaSlcbiAgKlxuICAqIEByZXR1cm4gIFByb21pc2VcbiAgKi9cblx0YnVmZmVyKCkge1xuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdC8qKlxuICAqIERlY29kZSByZXNwb25zZSBhcyB0ZXh0LCB3aGlsZSBhdXRvbWF0aWNhbGx5IGRldGVjdGluZyB0aGUgZW5jb2RpbmcgYW5kXG4gICogdHJ5aW5nIHRvIGRlY29kZSB0byBVVEYtOCAobm9uLXNwZWMgYXBpKVxuICAqXG4gICogQHJldHVybiAgUHJvbWlzZVxuICAqL1xuXHR0ZXh0Q29udmVydGVkKCkge1xuXHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIGNvbnN1bWVCb2R5LmNhbGwodGhpcykudGhlbihmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdFx0XHRyZXR1cm4gY29udmVydEJvZHkoYnVmZmVyLCBfdGhpczMuaGVhZGVycyk7XG5cdFx0fSk7XG5cdH1cbn07XG5cbi8vIEluIGJyb3dzZXJzLCBhbGwgcHJvcGVydGllcyBhcmUgZW51bWVyYWJsZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJvZHkucHJvdG90eXBlLCB7XG5cdGJvZHk6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRib2R5VXNlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGFycmF5QnVmZmVyOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0YmxvYjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGpzb246IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHR0ZXh0OiB7IGVudW1lcmFibGU6IHRydWUgfVxufSk7XG5cbkJvZHkubWl4SW4gPSBmdW5jdGlvbiAocHJvdG8pIHtcblx0Zm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKEJvZHkucHJvdG90eXBlKSkge1xuXHRcdC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBmdXR1cmUgcHJvb2Zcblx0XHRpZiAoIShuYW1lIGluIHByb3RvKSkge1xuXHRcdFx0Y29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQm9keS5wcm90b3R5cGUsIG5hbWUpO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBuYW1lLCBkZXNjKTtcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogQ29uc3VtZSBhbmQgY29udmVydCBhbiBlbnRpcmUgQm9keSB0byBhIEJ1ZmZlci5cbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktY29uc3VtZS1ib2R5XG4gKlxuICogQHJldHVybiAgUHJvbWlzZVxuICovXG5mdW5jdGlvbiBjb25zdW1lQm9keSgpIHtcblx0dmFyIF90aGlzNCA9IHRoaXM7XG5cblx0aWYgKHRoaXNbSU5URVJOQUxTXS5kaXN0dXJiZWQpIHtcblx0XHRyZXR1cm4gQm9keS5Qcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKGBib2R5IHVzZWQgYWxyZWFkeSBmb3I6ICR7dGhpcy51cmx9YCkpO1xuXHR9XG5cblx0dGhpc1tJTlRFUk5BTFNdLmRpc3R1cmJlZCA9IHRydWU7XG5cblx0aWYgKHRoaXNbSU5URVJOQUxTXS5lcnJvcikge1xuXHRcdHJldHVybiBCb2R5LlByb21pc2UucmVqZWN0KHRoaXNbSU5URVJOQUxTXS5lcnJvcik7XG5cdH1cblxuXHRsZXQgYm9keSA9IHRoaXMuYm9keTtcblxuXHQvLyBib2R5IGlzIG51bGxcblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gQm9keS5Qcm9taXNlLnJlc29sdmUoQnVmZmVyLmFsbG9jKDApKTtcblx0fVxuXG5cdC8vIGJvZHkgaXMgYmxvYlxuXHRpZiAoaXNCbG9iKGJvZHkpKSB7XG5cdFx0Ym9keSA9IGJvZHkuc3RyZWFtKCk7XG5cdH1cblxuXHQvLyBib2R5IGlzIGJ1ZmZlclxuXHRpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG5cdFx0cmV0dXJuIEJvZHkuUHJvbWlzZS5yZXNvbHZlKGJvZHkpO1xuXHR9XG5cblx0Ly8gaXN0YW5idWwgaWdub3JlIGlmOiBzaG91bGQgbmV2ZXIgaGFwcGVuXG5cdGlmICghKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pKSB7XG5cdFx0cmV0dXJuIEJvZHkuUHJvbWlzZS5yZXNvbHZlKEJ1ZmZlci5hbGxvYygwKSk7XG5cdH1cblxuXHQvLyBib2R5IGlzIHN0cmVhbVxuXHQvLyBnZXQgcmVhZHkgdG8gYWN0dWFsbHkgY29uc3VtZSB0aGUgYm9keVxuXHRsZXQgYWNjdW0gPSBbXTtcblx0bGV0IGFjY3VtQnl0ZXMgPSAwO1xuXHRsZXQgYWJvcnQgPSBmYWxzZTtcblxuXHRyZXR1cm4gbmV3IEJvZHkuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0bGV0IHJlc1RpbWVvdXQ7XG5cblx0XHQvLyBhbGxvdyB0aW1lb3V0IG9uIHNsb3cgcmVzcG9uc2UgYm9keVxuXHRcdGlmIChfdGhpczQudGltZW91dCkge1xuXHRcdFx0cmVzVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRhYm9ydCA9IHRydWU7XG5cdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgUmVzcG9uc2UgdGltZW91dCB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtfdGhpczQudXJsfSAob3ZlciAke190aGlzNC50aW1lb3V0fW1zKWAsICdib2R5LXRpbWVvdXQnKSk7XG5cdFx0XHR9LCBfdGhpczQudGltZW91dCk7XG5cdFx0fVxuXG5cdFx0Ly8gaGFuZGxlIHN0cmVhbSBlcnJvcnNcblx0XHRib2R5Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdGlmIChlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG5cdFx0XHRcdC8vIGlmIHRoZSByZXF1ZXN0IHdhcyBhYm9ydGVkLCByZWplY3Qgd2l0aCB0aGlzIEVycm9yXG5cdFx0XHRcdGFib3J0ID0gdHJ1ZTtcblx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBvdGhlciBlcnJvcnMsIHN1Y2ggYXMgaW5jb3JyZWN0IGNvbnRlbnQtZW5jb2Rpbmdcblx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGJvZHkgd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7X3RoaXM0LnVybH06ICR7ZXJyLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycikpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ym9keS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuXHRcdFx0aWYgKGFib3J0IHx8IGNodW5rID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKF90aGlzNC5zaXplICYmIGFjY3VtQnl0ZXMgKyBjaHVuay5sZW5ndGggPiBfdGhpczQuc2l6ZSkge1xuXHRcdFx0XHRhYm9ydCA9IHRydWU7XG5cdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgY29udGVudCBzaXplIGF0ICR7X3RoaXM0LnVybH0gb3ZlciBsaW1pdDogJHtfdGhpczQuc2l6ZX1gLCAnbWF4LXNpemUnKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0YWNjdW1CeXRlcyArPSBjaHVuay5sZW5ndGg7XG5cdFx0XHRhY2N1bS5wdXNoKGNodW5rKTtcblx0XHR9KTtcblxuXHRcdGJvZHkub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChhYm9ydCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNsZWFyVGltZW91dChyZXNUaW1lb3V0KTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzb2x2ZShCdWZmZXIuY29uY2F0KGFjY3VtLCBhY2N1bUJ5dGVzKSk7XG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0Ly8gaGFuZGxlIHN0cmVhbXMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRvbyBtdWNoIGRhdGEgKGlzc3VlICM0MTQpXG5cdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgQ291bGQgbm90IGNyZWF0ZSBCdWZmZXIgZnJvbSByZXNwb25zZSBib2R5IGZvciAke190aGlzNC51cmx9OiAke2Vyci5tZXNzYWdlfWAsICdzeXN0ZW0nLCBlcnIpKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogRGV0ZWN0IGJ1ZmZlciBlbmNvZGluZyBhbmQgY29udmVydCB0byB0YXJnZXQgZW5jb2RpbmdcbiAqIHJlZjogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9XRC1odG1sNS0yMDExMDExMy9wYXJzaW5nLmh0bWwjZGV0ZXJtaW5pbmctdGhlLWNoYXJhY3Rlci1lbmNvZGluZ1xuICpcbiAqIEBwYXJhbSAgIEJ1ZmZlciAgYnVmZmVyICAgIEluY29taW5nIGJ1ZmZlclxuICogQHBhcmFtICAgU3RyaW5nICBlbmNvZGluZyAgVGFyZ2V0IGVuY29kaW5nXG4gKiBAcmV0dXJuICBTdHJpbmdcbiAqL1xuZnVuY3Rpb24gY29udmVydEJvZHkoYnVmZmVyLCBoZWFkZXJzKSB7XG5cdGlmICh0eXBlb2YgY29udmVydCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyBFcnJvcignVGhlIHBhY2thZ2UgYGVuY29kaW5nYCBtdXN0IGJlIGluc3RhbGxlZCB0byB1c2UgdGhlIHRleHRDb252ZXJ0ZWQoKSBmdW5jdGlvbicpO1xuXHR9XG5cblx0Y29uc3QgY3QgPSBoZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG5cdGxldCBjaGFyc2V0ID0gJ3V0Zi04Jztcblx0bGV0IHJlcywgc3RyO1xuXG5cdC8vIGhlYWRlclxuXHRpZiAoY3QpIHtcblx0XHRyZXMgPSAvY2hhcnNldD0oW147XSopL2kuZXhlYyhjdCk7XG5cdH1cblxuXHQvLyBubyBjaGFyc2V0IGluIGNvbnRlbnQgdHlwZSwgcGVlayBhdCByZXNwb25zZSBib2R5IGZvciBhdCBtb3N0IDEwMjQgYnl0ZXNcblx0c3RyID0gYnVmZmVyLnNsaWNlKDAsIDEwMjQpLnRvU3RyaW5nKCk7XG5cblx0Ly8gaHRtbDVcblx0aWYgKCFyZXMgJiYgc3RyKSB7XG5cdFx0cmVzID0gLzxtZXRhLis/Y2hhcnNldD0oWydcIl0pKC4rPylcXDEvaS5leGVjKHN0cik7XG5cdH1cblxuXHQvLyBodG1sNFxuXHRpZiAoIXJlcyAmJiBzdHIpIHtcblx0XHRyZXMgPSAvPG1ldGFbXFxzXSs/aHR0cC1lcXVpdj0oWydcIl0pY29udGVudC10eXBlXFwxW1xcc10rP2NvbnRlbnQ9KFsnXCJdKSguKz8pXFwyL2kuZXhlYyhzdHIpO1xuXHRcdGlmICghcmVzKSB7XG5cdFx0XHRyZXMgPSAvPG1ldGFbXFxzXSs/Y29udGVudD0oWydcIl0pKC4rPylcXDFbXFxzXSs/aHR0cC1lcXVpdj0oWydcIl0pY29udGVudC10eXBlXFwzL2kuZXhlYyhzdHIpO1xuXHRcdFx0aWYgKHJlcykge1xuXHRcdFx0XHRyZXMucG9wKCk7IC8vIGRyb3AgbGFzdCBxdW90ZVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChyZXMpIHtcblx0XHRcdHJlcyA9IC9jaGFyc2V0PSguKikvaS5leGVjKHJlcy5wb3AoKSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8geG1sXG5cdGlmICghcmVzICYmIHN0cikge1xuXHRcdHJlcyA9IC88XFw/eG1sLis/ZW5jb2Rpbmc9KFsnXCJdKSguKz8pXFwxL2kuZXhlYyhzdHIpO1xuXHR9XG5cblx0Ly8gZm91bmQgY2hhcnNldFxuXHRpZiAocmVzKSB7XG5cdFx0Y2hhcnNldCA9IHJlcy5wb3AoKTtcblxuXHRcdC8vIHByZXZlbnQgZGVjb2RlIGlzc3VlcyB3aGVuIHNpdGVzIHVzZSBpbmNvcnJlY3QgZW5jb2Rpbmdcblx0XHQvLyByZWY6IGh0dHBzOi8vaHNpdm9uZW4uZmkvZW5jb2RpbmctbWVudS9cblx0XHRpZiAoY2hhcnNldCA9PT0gJ2diMjMxMicgfHwgY2hhcnNldCA9PT0gJ2diaycpIHtcblx0XHRcdGNoYXJzZXQgPSAnZ2IxODAzMCc7XG5cdFx0fVxuXHR9XG5cblx0Ly8gdHVybiByYXcgYnVmZmVycyBpbnRvIGEgc2luZ2xlIHV0Zi04IGJ1ZmZlclxuXHRyZXR1cm4gY29udmVydChidWZmZXIsICdVVEYtOCcsIGNoYXJzZXQpLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogRGV0ZWN0IGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICogcmVmOiBodHRwczovL2dpdGh1Yi5jb20vYml0aW5uL25vZGUtZmV0Y2gvaXNzdWVzLzI5NiNpc3N1ZWNvbW1lbnQtMzA3NTk4MTQzXG4gKlxuICogQHBhcmFtICAgT2JqZWN0ICBvYmogICAgIE9iamVjdCB0byBkZXRlY3QgYnkgdHlwZSBvciBicmFuZFxuICogQHJldHVybiAgU3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKG9iaikge1xuXHQvLyBEdWNrLXR5cGluZyBhcyBhIG5lY2Vzc2FyeSBjb25kaXRpb24uXG5cdGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqLmFwcGVuZCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmRlbGV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmdldEFsbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmhhcyAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLnNldCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIEJyYW5kLWNoZWNraW5nIGFuZCBtb3JlIGR1Y2stdHlwaW5nIGFzIG9wdGlvbmFsIGNvbmRpdGlvbi5cblx0cmV0dXJuIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVVJMU2VhcmNoUGFyYW1zJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgVVJMU2VhcmNoUGFyYW1zXScgfHwgdHlwZW9mIG9iai5zb3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgVzNDIGBCbG9iYCBvYmplY3QgKHdoaWNoIGBGaWxlYCBpbmhlcml0cyBmcm9tKVxuICogQHBhcmFtICB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Jsb2Iob2JqKSB7XG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmoudHlwZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIG9iai5zdHJlYW0gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdzdHJpbmcnICYmIC9eKEJsb2J8RmlsZSkkLy50ZXN0KG9iai5jb25zdHJ1Y3Rvci5uYW1lKSAmJiAvXihCbG9ifEZpbGUpJC8udGVzdChvYmpbU3ltYm9sLnRvU3RyaW5nVGFnXSk7XG59XG5cbi8qKlxuICogQ2xvbmUgYm9keSBnaXZlbiBSZXMvUmVxIGluc3RhbmNlXG4gKlxuICogQHBhcmFtICAgTWl4ZWQgIGluc3RhbmNlICBSZXNwb25zZSBvciBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcmV0dXJuICBNaXhlZFxuICovXG5mdW5jdGlvbiBjbG9uZShpbnN0YW5jZSkge1xuXHRsZXQgcDEsIHAyO1xuXHRsZXQgYm9keSA9IGluc3RhbmNlLmJvZHk7XG5cblx0Ly8gZG9uJ3QgYWxsb3cgY2xvbmluZyBhIHVzZWQgYm9keVxuXHRpZiAoaW5zdGFuY2UuYm9keVVzZWQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjbG9uZSBib2R5IGFmdGVyIGl0IGlzIHVzZWQnKTtcblx0fVxuXG5cdC8vIGNoZWNrIHRoYXQgYm9keSBpcyBhIHN0cmVhbSBhbmQgbm90IGZvcm0tZGF0YSBvYmplY3Rcblx0Ly8gbm90ZTogd2UgY2FuJ3QgY2xvbmUgdGhlIGZvcm0tZGF0YSBvYmplY3Qgd2l0aG91dCBoYXZpbmcgaXQgYXMgYSBkZXBlbmRlbmN5XG5cdGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtICYmIHR5cGVvZiBib2R5LmdldEJvdW5kYXJ5ICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gdGVlIGluc3RhbmNlIGJvZHlcblx0XHRwMSA9IG5ldyBQYXNzVGhyb3VnaCgpO1xuXHRcdHAyID0gbmV3IFBhc3NUaHJvdWdoKCk7XG5cdFx0Ym9keS5waXBlKHAxKTtcblx0XHRib2R5LnBpcGUocDIpO1xuXHRcdC8vIHNldCBpbnN0YW5jZSBib2R5IHRvIHRlZWQgYm9keSBhbmQgcmV0dXJuIHRoZSBvdGhlciB0ZWVkIGJvZHlcblx0XHRpbnN0YW5jZVtJTlRFUk5BTFNdLmJvZHkgPSBwMTtcblx0XHRib2R5ID0gcDI7XG5cdH1cblxuXHRyZXR1cm4gYm9keTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyB0aGUgb3BlcmF0aW9uIFwiZXh0cmFjdCBhIGBDb250ZW50LVR5cGVgIHZhbHVlIGZyb20gfG9iamVjdHxcIiBhc1xuICogc3BlY2lmaWVkIGluIHRoZSBzcGVjaWZpY2F0aW9uOlxuICogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keWluaXQtZXh0cmFjdFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGluc3RhbmNlLmJvZHkgaXMgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0gICBNaXhlZCAgaW5zdGFuY2UgIEFueSBvcHRpb25zLmJvZHkgaW5wdXRcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbnRlbnRUeXBlKGJvZHkpIHtcblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHQvLyBib2R5IGlzIG51bGxcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcblx0XHQvLyBib2R5IGlzIHN0cmluZ1xuXHRcdHJldHVybiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jztcblx0fSBlbHNlIGlmIChpc1VSTFNlYXJjaFBhcmFtcyhib2R5KSkge1xuXHRcdC8vIGJvZHkgaXMgYSBVUkxTZWFyY2hQYXJhbXNcblx0XHRyZXR1cm4gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jztcblx0fSBlbHNlIGlmIChpc0Jsb2IoYm9keSkpIHtcblx0XHQvLyBib2R5IGlzIGJsb2Jcblx0XHRyZXR1cm4gYm9keS50eXBlIHx8IG51bGw7XG5cdH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBidWZmZXJcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcblx0XHQvLyBib2R5IGlzIEFycmF5QnVmZmVyXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBBcnJheUJ1ZmZlclZpZXdcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIGlmICh0eXBlb2YgYm9keS5nZXRCb3VuZGFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdC8vIGRldGVjdCBmb3JtIGRhdGEgaW5wdXQgZnJvbSBmb3JtLWRhdGEgbW9kdWxlXG5cdFx0cmV0dXJuIGBtdWx0aXBhcnQvZm9ybS1kYXRhO2JvdW5kYXJ5PSR7Ym9keS5nZXRCb3VuZGFyeSgpfWA7XG5cdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkge1xuXHRcdC8vIGJvZHkgaXMgc3RyZWFtXG5cdFx0Ly8gY2FuJ3QgcmVhbGx5IGRvIG11Y2ggYWJvdXQgdGhpc1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEJvZHkgY29uc3RydWN0b3IgZGVmYXVsdHMgb3RoZXIgdGhpbmdzIHRvIHN0cmluZ1xuXHRcdHJldHVybiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jztcblx0fVxufVxuXG4vKipcbiAqIFRoZSBGZXRjaCBTdGFuZGFyZCB0cmVhdHMgdGhpcyBhcyBpZiBcInRvdGFsIGJ5dGVzXCIgaXMgYSBwcm9wZXJ0eSBvbiB0aGUgYm9keS5cbiAqIEZvciB1cywgd2UgaGF2ZSB0byBleHBsaWNpdGx5IGdldCBpdCB3aXRoIGEgZnVuY3Rpb24uXG4gKlxuICogcmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LXRvdGFsLWJ5dGVzXG4gKlxuICogQHBhcmFtICAgQm9keSAgICBpbnN0YW5jZSAgIEluc3RhbmNlIG9mIEJvZHlcbiAqIEByZXR1cm4gIE51bWJlcj8gICAgICAgICAgICBOdW1iZXIgb2YgYnl0ZXMsIG9yIG51bGwgaWYgbm90IHBvc3NpYmxlXG4gKi9cbmZ1bmN0aW9uIGdldFRvdGFsQnl0ZXMoaW5zdGFuY2UpIHtcblx0Y29uc3QgYm9keSA9IGluc3RhbmNlLmJvZHk7XG5cblxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdC8vIGJvZHkgaXMgbnVsbFxuXHRcdHJldHVybiAwO1xuXHR9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkge1xuXHRcdHJldHVybiBib2R5LnNpemU7XG5cdH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBidWZmZXJcblx0XHRyZXR1cm4gYm9keS5sZW5ndGg7XG5cdH0gZWxzZSBpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5nZXRMZW5ndGhTeW5jID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gZGV0ZWN0IGZvcm0gZGF0YSBpbnB1dCBmcm9tIGZvcm0tZGF0YSBtb2R1bGVcblx0XHRpZiAoYm9keS5fbGVuZ3RoUmV0cmlldmVycyAmJiBib2R5Ll9sZW5ndGhSZXRyaWV2ZXJzLmxlbmd0aCA9PSAwIHx8IC8vIDEueFxuXHRcdGJvZHkuaGFzS25vd25MZW5ndGggJiYgYm9keS5oYXNLbm93bkxlbmd0aCgpKSB7XG5cdFx0XHQvLyAyLnhcblx0XHRcdHJldHVybiBib2R5LmdldExlbmd0aFN5bmMoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gYm9keSBpcyBzdHJlYW1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIFdyaXRlIGEgQm9keSB0byBhIE5vZGUuanMgV3JpdGFibGVTdHJlYW0gKGUuZy4gaHR0cC5SZXF1ZXN0KSBvYmplY3QuXG4gKlxuICogQHBhcmFtICAgQm9keSAgICBpbnN0YW5jZSAgIEluc3RhbmNlIG9mIEJvZHlcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuZnVuY3Rpb24gd3JpdGVUb1N0cmVhbShkZXN0LCBpbnN0YW5jZSkge1xuXHRjb25zdCBib2R5ID0gaW5zdGFuY2UuYm9keTtcblxuXG5cdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0Ly8gYm9keSBpcyBudWxsXG5cdFx0ZGVzdC5lbmQoKTtcblx0fSBlbHNlIGlmIChpc0Jsb2IoYm9keSkpIHtcblx0XHRib2R5LnN0cmVhbSgpLnBpcGUoZGVzdCk7XG5cdH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBidWZmZXJcblx0XHRkZXN0LndyaXRlKGJvZHkpO1xuXHRcdGRlc3QuZW5kKCk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gYm9keSBpcyBzdHJlYW1cblx0XHRib2R5LnBpcGUoZGVzdCk7XG5cdH1cbn1cblxuLy8gZXhwb3NlIFByb21pc2VcbkJvZHkuUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xuXG4vKipcbiAqIGhlYWRlcnMuanNcbiAqXG4gKiBIZWFkZXJzIGNsYXNzIG9mZmVycyBjb252ZW5pZW50IGhlbHBlcnNcbiAqL1xuXG5jb25zdCBpbnZhbGlkVG9rZW5SZWdleCA9IC9bXlxcXl9gYS16QS1aXFwtMC05ISMkJSYnKisufH5dLztcbmNvbnN0IGludmFsaWRIZWFkZXJDaGFyUmVnZXggPSAvW15cXHRcXHgyMC1cXHg3ZVxceDgwLVxceGZmXS87XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTmFtZShuYW1lKSB7XG5cdG5hbWUgPSBgJHtuYW1lfWA7XG5cdGlmIChpbnZhbGlkVG9rZW5SZWdleC50ZXN0KG5hbWUpIHx8IG5hbWUgPT09ICcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgJHtuYW1lfSBpcyBub3QgYSBsZWdhbCBIVFRQIGhlYWRlciBuYW1lYCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWx1ZSkge1xuXHR2YWx1ZSA9IGAke3ZhbHVlfWA7XG5cdGlmIChpbnZhbGlkSGVhZGVyQ2hhclJlZ2V4LnRlc3QodmFsdWUpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgbGVnYWwgSFRUUCBoZWFkZXIgdmFsdWVgKTtcblx0fVxufVxuXG4vKipcbiAqIEZpbmQgdGhlIGtleSBpbiB0aGUgbWFwIG9iamVjdCBnaXZlbiBhIGhlYWRlciBuYW1lLlxuICpcbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAqXG4gKiBAcGFyYW0gICBTdHJpbmcgIG5hbWUgIEhlYWRlciBuYW1lXG4gKiBAcmV0dXJuICBTdHJpbmd8VW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGZpbmQobWFwLCBuYW1lKSB7XG5cdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdGZvciAoY29uc3Qga2V5IGluIG1hcCkge1xuXHRcdGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSkge1xuXHRcdFx0cmV0dXJuIGtleTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuY29uc3QgTUFQID0gU3ltYm9sKCdtYXAnKTtcbmNsYXNzIEhlYWRlcnMge1xuXHQvKipcbiAgKiBIZWFkZXJzIGNsYXNzXG4gICpcbiAgKiBAcGFyYW0gICBPYmplY3QgIGhlYWRlcnMgIFJlc3BvbnNlIGhlYWRlcnNcbiAgKiBAcmV0dXJuICBWb2lkXG4gICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGxldCBpbml0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQ7XG5cblx0XHR0aGlzW01BUF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdFx0aWYgKGluaXQgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG5cdFx0XHRjb25zdCByYXdIZWFkZXJzID0gaW5pdC5yYXcoKTtcblx0XHRcdGNvbnN0IGhlYWRlck5hbWVzID0gT2JqZWN0LmtleXMocmF3SGVhZGVycyk7XG5cblx0XHRcdGZvciAoY29uc3QgaGVhZGVyTmFtZSBvZiBoZWFkZXJOYW1lcykge1xuXHRcdFx0XHRmb3IgKGNvbnN0IHZhbHVlIG9mIHJhd0hlYWRlcnNbaGVhZGVyTmFtZV0pIHtcblx0XHRcdFx0XHR0aGlzLmFwcGVuZChoZWFkZXJOYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFdlIGRvbid0IHdvcnJ5IGFib3V0IGNvbnZlcnRpbmcgcHJvcCB0byBCeXRlU3RyaW5nIGhlcmUgYXMgYXBwZW5kKClcblx0XHQvLyB3aWxsIGhhbmRsZSBpdC5cblx0XHRpZiAoaW5pdCA9PSBudWxsKSA7IGVsc2UgaWYgKHR5cGVvZiBpbml0ID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Y29uc3QgbWV0aG9kID0gaW5pdFtTeW1ib2wuaXRlcmF0b3JdO1xuXHRcdFx0aWYgKG1ldGhvZCAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgbWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignSGVhZGVyIHBhaXJzIG11c3QgYmUgaXRlcmFibGUnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PlxuXHRcdFx0XHQvLyBOb3RlOiBwZXIgc3BlYyB3ZSBoYXZlIHRvIGZpcnN0IGV4aGF1c3QgdGhlIGxpc3RzIHRoZW4gcHJvY2VzcyB0aGVtXG5cdFx0XHRcdGNvbnN0IHBhaXJzID0gW107XG5cdFx0XHRcdGZvciAoY29uc3QgcGFpciBvZiBpbml0KSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBwYWlyICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFpcltTeW1ib2wuaXRlcmF0b3JdICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFYWNoIGhlYWRlciBwYWlyIG11c3QgYmUgaXRlcmFibGUnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFpcnMucHVzaChBcnJheS5mcm9tKHBhaXIpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuXHRcdFx0XHRcdGlmIChwYWlyLmxlbmd0aCAhPT0gMikge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRWFjaCBoZWFkZXIgcGFpciBtdXN0IGJlIGEgbmFtZS92YWx1ZSB0dXBsZScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmFwcGVuZChwYWlyWzBdLCBwYWlyWzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gcmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+XG5cdFx0XHRcdGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGluaXQpKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSBpbml0W2tleV07XG5cdFx0XHRcdFx0dGhpcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignUHJvdmlkZWQgaW5pdGlhbGl6ZXIgbXVzdCBiZSBhbiBvYmplY3QnKTtcblx0XHR9XG5cdH1cblxuXHQvKipcbiAgKiBSZXR1cm4gY29tYmluZWQgaGVhZGVyIHZhbHVlIGdpdmVuIG5hbWVcbiAgKlxuICAqIEBwYXJhbSAgIFN0cmluZyAgbmFtZSAgSGVhZGVyIG5hbWVcbiAgKiBAcmV0dXJuICBNaXhlZFxuICAqL1xuXHRnZXQobmFtZSkge1xuXHRcdG5hbWUgPSBgJHtuYW1lfWA7XG5cdFx0dmFsaWRhdGVOYW1lKG5hbWUpO1xuXHRcdGNvbnN0IGtleSA9IGZpbmQodGhpc1tNQVBdLCBuYW1lKTtcblx0XHRpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzW01BUF1ba2V5XS5qb2luKCcsICcpO1xuXHR9XG5cblx0LyoqXG4gICogSXRlcmF0ZSBvdmVyIGFsbCBoZWFkZXJzXG4gICpcbiAgKiBAcGFyYW0gICBGdW5jdGlvbiAgY2FsbGJhY2sgIEV4ZWN1dGVkIGZvciBlYWNoIGl0ZW0gd2l0aCBwYXJhbWV0ZXJzICh2YWx1ZSwgbmFtZSwgdGhpc0FyZylcbiAgKiBAcGFyYW0gICBCb29sZWFuICAgdGhpc0FyZyAgIGB0aGlzYCBjb250ZXh0IGZvciBjYWxsYmFjayBmdW5jdGlvblxuICAqIEByZXR1cm4gIFZvaWRcbiAgKi9cblx0Zm9yRWFjaChjYWxsYmFjaykge1xuXHRcdGxldCB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG5cblx0XHRsZXQgcGFpcnMgPSBnZXRIZWFkZXJzKHRoaXMpO1xuXHRcdGxldCBpID0gMDtcblx0XHR3aGlsZSAoaSA8IHBhaXJzLmxlbmd0aCkge1xuXHRcdFx0dmFyIF9wYWlycyRpID0gcGFpcnNbaV07XG5cdFx0XHRjb25zdCBuYW1lID0gX3BhaXJzJGlbMF0sXG5cdFx0XHQgICAgICB2YWx1ZSA9IF9wYWlycyRpWzFdO1xuXG5cdFx0XHRjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCB0aGlzKTtcblx0XHRcdHBhaXJzID0gZ2V0SGVhZGVycyh0aGlzKTtcblx0XHRcdGkrKztcblx0XHR9XG5cdH1cblxuXHQvKipcbiAgKiBPdmVyd3JpdGUgaGVhZGVyIHZhbHVlcyBnaXZlbiBuYW1lXG4gICpcbiAgKiBAcGFyYW0gICBTdHJpbmcgIG5hbWUgICBIZWFkZXIgbmFtZVxuICAqIEBwYXJhbSAgIFN0cmluZyAgdmFsdWUgIEhlYWRlciB2YWx1ZVxuICAqIEByZXR1cm4gIFZvaWRcbiAgKi9cblx0c2V0KG5hbWUsIHZhbHVlKSB7XG5cdFx0bmFtZSA9IGAke25hbWV9YDtcblx0XHR2YWx1ZSA9IGAke3ZhbHVlfWA7XG5cdFx0dmFsaWRhdGVOYW1lKG5hbWUpO1xuXHRcdHZhbGlkYXRlVmFsdWUodmFsdWUpO1xuXHRcdGNvbnN0IGtleSA9IGZpbmQodGhpc1tNQVBdLCBuYW1lKTtcblx0XHR0aGlzW01BUF1ba2V5ICE9PSB1bmRlZmluZWQgPyBrZXkgOiBuYW1lXSA9IFt2YWx1ZV07XG5cdH1cblxuXHQvKipcbiAgKiBBcHBlbmQgYSB2YWx1ZSBvbnRvIGV4aXN0aW5nIGhlYWRlclxuICAqXG4gICogQHBhcmFtICAgU3RyaW5nICBuYW1lICAgSGVhZGVyIG5hbWVcbiAgKiBAcGFyYW0gICBTdHJpbmcgIHZhbHVlICBIZWFkZXIgdmFsdWVcbiAgKiBAcmV0dXJuICBWb2lkXG4gICovXG5cdGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuXHRcdG5hbWUgPSBgJHtuYW1lfWA7XG5cdFx0dmFsdWUgPSBgJHt2YWx1ZX1gO1xuXHRcdHZhbGlkYXRlTmFtZShuYW1lKTtcblx0XHR2YWxpZGF0ZVZhbHVlKHZhbHVlKTtcblx0XHRjb25zdCBrZXkgPSBmaW5kKHRoaXNbTUFQXSwgbmFtZSk7XG5cdFx0aWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzW01BUF1ba2V5XS5wdXNoKHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpc1tNQVBdW25hbWVdID0gW3ZhbHVlXTtcblx0XHR9XG5cdH1cblxuXHQvKipcbiAgKiBDaGVjayBmb3IgaGVhZGVyIG5hbWUgZXhpc3RlbmNlXG4gICpcbiAgKiBAcGFyYW0gICBTdHJpbmcgICBuYW1lICBIZWFkZXIgbmFtZVxuICAqIEByZXR1cm4gIEJvb2xlYW5cbiAgKi9cblx0aGFzKG5hbWUpIHtcblx0XHRuYW1lID0gYCR7bmFtZX1gO1xuXHRcdHZhbGlkYXRlTmFtZShuYW1lKTtcblx0XHRyZXR1cm4gZmluZCh0aGlzW01BUF0sIG5hbWUpICE9PSB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKipcbiAgKiBEZWxldGUgYWxsIGhlYWRlciB2YWx1ZXMgZ2l2ZW4gbmFtZVxuICAqXG4gICogQHBhcmFtICAgU3RyaW5nICBuYW1lICBIZWFkZXIgbmFtZVxuICAqIEByZXR1cm4gIFZvaWRcbiAgKi9cblx0ZGVsZXRlKG5hbWUpIHtcblx0XHRuYW1lID0gYCR7bmFtZX1gO1xuXHRcdHZhbGlkYXRlTmFtZShuYW1lKTtcblx0XHRjb25zdCBrZXkgPSBmaW5kKHRoaXNbTUFQXSwgbmFtZSk7XG5cdFx0aWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkZWxldGUgdGhpc1tNQVBdW2tleV07XG5cdFx0fVxuXHR9XG5cblx0LyoqXG4gICogUmV0dXJuIHJhdyBoZWFkZXJzIChub24tc3BlYyBhcGkpXG4gICpcbiAgKiBAcmV0dXJuICBPYmplY3RcbiAgKi9cblx0cmF3KCkge1xuXHRcdHJldHVybiB0aGlzW01BUF07XG5cdH1cblxuXHQvKipcbiAgKiBHZXQgYW4gaXRlcmF0b3Igb24ga2V5cy5cbiAgKlxuICAqIEByZXR1cm4gIEl0ZXJhdG9yXG4gICovXG5cdGtleXMoKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZUhlYWRlcnNJdGVyYXRvcih0aGlzLCAna2V5Jyk7XG5cdH1cblxuXHQvKipcbiAgKiBHZXQgYW4gaXRlcmF0b3Igb24gdmFsdWVzLlxuICAqXG4gICogQHJldHVybiAgSXRlcmF0b3JcbiAgKi9cblx0dmFsdWVzKCkge1xuXHRcdHJldHVybiBjcmVhdGVIZWFkZXJzSXRlcmF0b3IodGhpcywgJ3ZhbHVlJyk7XG5cdH1cblxuXHQvKipcbiAgKiBHZXQgYW4gaXRlcmF0b3Igb24gZW50cmllcy5cbiAgKlxuICAqIFRoaXMgaXMgdGhlIGRlZmF1bHQgaXRlcmF0b3Igb2YgdGhlIEhlYWRlcnMgb2JqZWN0LlxuICAqXG4gICogQHJldHVybiAgSXRlcmF0b3JcbiAgKi9cblx0W1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZUhlYWRlcnNJdGVyYXRvcih0aGlzLCAna2V5K3ZhbHVlJyk7XG5cdH1cbn1cbkhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSGVhZGVycy5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuXHR2YWx1ZTogJ0hlYWRlcnMnLFxuXHR3cml0YWJsZTogZmFsc2UsXG5cdGVudW1lcmFibGU6IGZhbHNlLFxuXHRjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhIZWFkZXJzLnByb3RvdHlwZSwge1xuXHRnZXQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRmb3JFYWNoOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0c2V0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0YXBwZW5kOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0aGFzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0ZGVsZXRlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0a2V5czogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHZhbHVlczogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGVudHJpZXM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcblxuZnVuY3Rpb24gZ2V0SGVhZGVycyhoZWFkZXJzKSB7XG5cdGxldCBraW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAna2V5K3ZhbHVlJztcblxuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVyc1tNQVBdKS5zb3J0KCk7XG5cdHJldHVybiBrZXlzLm1hcChraW5kID09PSAna2V5JyA/IGZ1bmN0aW9uIChrKSB7XG5cdFx0cmV0dXJuIGsudG9Mb3dlckNhc2UoKTtcblx0fSA6IGtpbmQgPT09ICd2YWx1ZScgPyBmdW5jdGlvbiAoaykge1xuXHRcdHJldHVybiBoZWFkZXJzW01BUF1ba10uam9pbignLCAnKTtcblx0fSA6IGZ1bmN0aW9uIChrKSB7XG5cdFx0cmV0dXJuIFtrLnRvTG93ZXJDYXNlKCksIGhlYWRlcnNbTUFQXVtrXS5qb2luKCcsICcpXTtcblx0fSk7XG59XG5cbmNvbnN0IElOVEVSTkFMID0gU3ltYm9sKCdpbnRlcm5hbCcpO1xuXG5mdW5jdGlvbiBjcmVhdGVIZWFkZXJzSXRlcmF0b3IodGFyZ2V0LCBraW5kKSB7XG5cdGNvbnN0IGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShIZWFkZXJzSXRlcmF0b3JQcm90b3R5cGUpO1xuXHRpdGVyYXRvcltJTlRFUk5BTF0gPSB7XG5cdFx0dGFyZ2V0LFxuXHRcdGtpbmQsXG5cdFx0aW5kZXg6IDBcblx0fTtcblx0cmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5jb25zdCBIZWFkZXJzSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2Yoe1xuXHRuZXh0KCkge1xuXHRcdC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuXHRcdGlmICghdGhpcyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykgIT09IEhlYWRlcnNJdGVyYXRvclByb3RvdHlwZSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWUgb2YgYHRoaXNgIGlzIG5vdCBhIEhlYWRlcnNJdGVyYXRvcicpO1xuXHRcdH1cblxuXHRcdHZhciBfSU5URVJOQUwgPSB0aGlzW0lOVEVSTkFMXTtcblx0XHRjb25zdCB0YXJnZXQgPSBfSU5URVJOQUwudGFyZ2V0LFxuXHRcdCAgICAgIGtpbmQgPSBfSU5URVJOQUwua2luZCxcblx0XHQgICAgICBpbmRleCA9IF9JTlRFUk5BTC5pbmRleDtcblxuXHRcdGNvbnN0IHZhbHVlcyA9IGdldEhlYWRlcnModGFyZ2V0LCBraW5kKTtcblx0XHRjb25zdCBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuXHRcdGlmIChpbmRleCA+PSBsZW4pIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHZhbHVlOiB1bmRlZmluZWQsXG5cdFx0XHRcdGRvbmU6IHRydWVcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dGhpc1tJTlRFUk5BTF0uaW5kZXggPSBpbmRleCArIDE7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dmFsdWU6IHZhbHVlc1tpbmRleF0sXG5cdFx0XHRkb25lOiBmYWxzZVxuXHRcdH07XG5cdH1cbn0sIE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSGVhZGVyc0l0ZXJhdG9yUHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcblx0dmFsdWU6ICdIZWFkZXJzSXRlcmF0b3InLFxuXHR3cml0YWJsZTogZmFsc2UsXG5cdGVudW1lcmFibGU6IGZhbHNlLFxuXHRjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgSGVhZGVycyBvYmplY3QgaW4gYSBmb3JtIHRoYXQgTm9kZS5qcyBjYW4gY29uc3VtZS5cbiAqXG4gKiBAcGFyYW0gICBIZWFkZXJzICBoZWFkZXJzXG4gKiBAcmV0dXJuICBPYmplY3RcbiAqL1xuZnVuY3Rpb24gZXhwb3J0Tm9kZUNvbXBhdGlibGVIZWFkZXJzKGhlYWRlcnMpIHtcblx0Y29uc3Qgb2JqID0gT2JqZWN0LmFzc2lnbih7IF9fcHJvdG9fXzogbnVsbCB9LCBoZWFkZXJzW01BUF0pO1xuXG5cdC8vIGh0dHAucmVxdWVzdCgpIG9ubHkgc3VwcG9ydHMgc3RyaW5nIGFzIEhvc3QgaGVhZGVyLiBUaGlzIGhhY2sgbWFrZXNcblx0Ly8gc3BlY2lmeWluZyBjdXN0b20gSG9zdCBoZWFkZXIgcG9zc2libGUuXG5cdGNvbnN0IGhvc3RIZWFkZXJLZXkgPSBmaW5kKGhlYWRlcnNbTUFQXSwgJ0hvc3QnKTtcblx0aWYgKGhvc3RIZWFkZXJLZXkgIT09IHVuZGVmaW5lZCkge1xuXHRcdG9ialtob3N0SGVhZGVyS2V5XSA9IG9ialtob3N0SGVhZGVyS2V5XVswXTtcblx0fVxuXG5cdHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgSGVhZGVycyBvYmplY3QgZnJvbSBhbiBvYmplY3Qgb2YgaGVhZGVycywgaWdub3JpbmcgdGhvc2UgdGhhdCBkb1xuICogbm90IGNvbmZvcm0gdG8gSFRUUCBncmFtbWFyIHByb2R1Y3Rpb25zLlxuICpcbiAqIEBwYXJhbSAgIE9iamVjdCAgb2JqICBPYmplY3Qgb2YgaGVhZGVyc1xuICogQHJldHVybiAgSGVhZGVyc1xuICovXG5mdW5jdGlvbiBjcmVhdGVIZWFkZXJzTGVuaWVudChvYmopIHtcblx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG5cdGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG5cdFx0aWYgKGludmFsaWRUb2tlblJlZ2V4LnRlc3QobmFtZSkpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmpbbmFtZV0pKSB7XG5cdFx0XHRmb3IgKGNvbnN0IHZhbCBvZiBvYmpbbmFtZV0pIHtcblx0XHRcdFx0aWYgKGludmFsaWRIZWFkZXJDaGFyUmVnZXgudGVzdCh2YWwpKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhlYWRlcnNbTUFQXVtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1tNQVBdW25hbWVdID0gW3ZhbF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGVhZGVyc1tNQVBdW25hbWVdLnB1c2godmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIWludmFsaWRIZWFkZXJDaGFyUmVnZXgudGVzdChvYmpbbmFtZV0pKSB7XG5cdFx0XHRoZWFkZXJzW01BUF1bbmFtZV0gPSBbb2JqW25hbWVdXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGhlYWRlcnM7XG59XG5cbmNvbnN0IElOVEVSTkFMUyQxID0gU3ltYm9sKCdSZXNwb25zZSBpbnRlcm5hbHMnKTtcblxuLy8gZml4IGFuIGlzc3VlIHdoZXJlIFwiU1RBVFVTX0NPREVTXCIgYXJlbid0IGEgbmFtZWQgZXhwb3J0IGZvciBub2RlIDwxMFxuY29uc3QgU1RBVFVTX0NPREVTID0gaHR0cC5TVEFUVVNfQ09ERVM7XG5cbi8qKlxuICogUmVzcG9uc2UgY2xhc3NcbiAqXG4gKiBAcGFyYW0gICBTdHJlYW0gIGJvZHkgIFJlYWRhYmxlIHN0cmVhbVxuICogQHBhcmFtICAgT2JqZWN0ICBvcHRzICBSZXNwb25zZSBvcHRpb25zXG4gKiBAcmV0dXJuICBWb2lkXG4gKi9cbmNsYXNzIFJlc3BvbnNlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0bGV0IGJvZHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cdFx0bGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG5cdFx0Qm9keS5jYWxsKHRoaXMsIGJvZHksIG9wdHMpO1xuXG5cdFx0Y29uc3Qgc3RhdHVzID0gb3B0cy5zdGF0dXMgfHwgMjAwO1xuXHRcdGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRzLmhlYWRlcnMpO1xuXG5cdFx0aWYgKGJvZHkgIT0gbnVsbCAmJiAhaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpKSB7XG5cdFx0XHRjb25zdCBjb250ZW50VHlwZSA9IGV4dHJhY3RDb250ZW50VHlwZShib2R5KTtcblx0XHRcdGlmIChjb250ZW50VHlwZSkge1xuXHRcdFx0XHRoZWFkZXJzLmFwcGVuZCgnQ29udGVudC1UeXBlJywgY29udGVudFR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXNbSU5URVJOQUxTJDFdID0ge1xuXHRcdFx0dXJsOiBvcHRzLnVybCxcblx0XHRcdHN0YXR1cyxcblx0XHRcdHN0YXR1c1RleHQ6IG9wdHMuc3RhdHVzVGV4dCB8fCBTVEFUVVNfQ09ERVNbc3RhdHVzXSxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRjb3VudGVyOiBvcHRzLmNvdW50ZXJcblx0XHR9O1xuXHR9XG5cblx0Z2V0IHVybCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0udXJsIHx8ICcnO1xuXHR9XG5cblx0Z2V0IHN0YXR1cygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzO1xuXHR9XG5cblx0LyoqXG4gICogQ29udmVuaWVuY2UgcHJvcGVydHkgcmVwcmVzZW50aW5nIGlmIHRoZSByZXF1ZXN0IGVuZGVkIG5vcm1hbGx5XG4gICovXG5cdGdldCBvaygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzID49IDIwMCAmJiB0aGlzW0lOVEVSTkFMUyQxXS5zdGF0dXMgPCAzMDA7XG5cdH1cblxuXHRnZXQgcmVkaXJlY3RlZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uY291bnRlciA+IDA7XG5cdH1cblxuXHRnZXQgc3RhdHVzVGV4dCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzVGV4dDtcblx0fVxuXG5cdGdldCBoZWFkZXJzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5oZWFkZXJzO1xuXHR9XG5cblx0LyoqXG4gICogQ2xvbmUgdGhpcyByZXNwb25zZVxuICAqXG4gICogQHJldHVybiAgUmVzcG9uc2VcbiAgKi9cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyBSZXNwb25zZShjbG9uZSh0aGlzKSwge1xuXHRcdFx0dXJsOiB0aGlzLnVybCxcblx0XHRcdHN0YXR1czogdGhpcy5zdGF0dXMsXG5cdFx0XHRzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRvazogdGhpcy5vayxcblx0XHRcdHJlZGlyZWN0ZWQ6IHRoaXMucmVkaXJlY3RlZFxuXHRcdH0pO1xuXHR9XG59XG5cbkJvZHkubWl4SW4oUmVzcG9uc2UucHJvdG90eXBlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVzcG9uc2UucHJvdG90eXBlLCB7XG5cdHVybDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHN0YXR1czogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdG9rOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0cmVkaXJlY3RlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHN0YXR1c1RleHQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRoZWFkZXJzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0Y2xvbmU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlc3BvbnNlLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG5cdHZhbHVlOiAnUmVzcG9uc2UnLFxuXHR3cml0YWJsZTogZmFsc2UsXG5cdGVudW1lcmFibGU6IGZhbHNlLFxuXHRjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5jb25zdCBJTlRFUk5BTFMkMiA9IFN5bWJvbCgnUmVxdWVzdCBpbnRlcm5hbHMnKTtcbmNvbnN0IFVSTCA9IFVybC5VUkwgfHwgd2hhdHdnVXJsLlVSTDtcblxuLy8gZml4IGFuIGlzc3VlIHdoZXJlIFwiZm9ybWF0XCIsIFwicGFyc2VcIiBhcmVuJ3QgYSBuYW1lZCBleHBvcnQgZm9yIG5vZGUgPDEwXG5jb25zdCBwYXJzZV91cmwgPSBVcmwucGFyc2U7XG5jb25zdCBmb3JtYXRfdXJsID0gVXJsLmZvcm1hdDtcblxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCBgbmV3IFVSTGAgdG8gaGFuZGxlIGFyYml0cmFyeSBVUkxzXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB1cmxTdHJcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVVJMKHVybFN0cikge1xuXHQvKlxuIFx0Q2hlY2sgd2hldGhlciB0aGUgVVJMIGlzIGFic29sdXRlIG9yIG5vdFxuIFx0XHRTY2hlbWU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4gXHRBYnNvbHV0ZSBVUkw6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNC4zXG4gKi9cblx0aWYgKC9eW2EtekEtWl1bYS16QS1aXFxkK1xcLS5dKjovLmV4ZWModXJsU3RyKSkge1xuXHRcdHVybFN0ciA9IG5ldyBVUkwodXJsU3RyKS50b1N0cmluZygpO1xuXHR9XG5cblx0Ly8gRmFsbGJhY2sgdG8gb2xkIGltcGxlbWVudGF0aW9uIGZvciBhcmJpdHJhcnkgVVJMc1xuXHRyZXR1cm4gcGFyc2VfdXJsKHVybFN0cik7XG59XG5cbmNvbnN0IHN0cmVhbURlc3RydWN0aW9uU3VwcG9ydGVkID0gJ2Rlc3Ryb3knIGluIFN0cmVhbS5SZWFkYWJsZS5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBSZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSAgIE1peGVkICAgaW5wdXRcbiAqIEByZXR1cm4gIEJvb2xlYW5cbiAqL1xuZnVuY3Rpb24gaXNSZXF1ZXN0KGlucHV0KSB7XG5cdHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnB1dFtJTlRFUk5BTFMkMl0gPT09ICdvYmplY3QnO1xufVxuXG5mdW5jdGlvbiBpc0Fib3J0U2lnbmFsKHNpZ25hbCkge1xuXHRjb25zdCBwcm90byA9IHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsID09PSAnb2JqZWN0JyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2lnbmFsKTtcblx0cmV0dXJuICEhKHByb3RvICYmIHByb3RvLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBYm9ydFNpZ25hbCcpO1xufVxuXG4vKipcbiAqIFJlcXVlc3QgY2xhc3NcbiAqXG4gKiBAcGFyYW0gICBNaXhlZCAgIGlucHV0ICBVcmwgb3IgUmVxdWVzdCBpbnN0YW5jZVxuICogQHBhcmFtICAgT2JqZWN0ICBpbml0ICAgQ3VzdG9tIG9wdGlvbnNcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuY2xhc3MgUmVxdWVzdCB7XG5cdGNvbnN0cnVjdG9yKGlucHV0KSB7XG5cdFx0bGV0IGluaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG5cdFx0bGV0IHBhcnNlZFVSTDtcblxuXHRcdC8vIG5vcm1hbGl6ZSBpbnB1dFxuXHRcdGlmICghaXNSZXF1ZXN0KGlucHV0KSkge1xuXHRcdFx0aWYgKGlucHV0ICYmIGlucHV0LmhyZWYpIHtcblx0XHRcdFx0Ly8gaW4gb3JkZXIgdG8gc3VwcG9ydCBOb2RlLmpzJyBVcmwgb2JqZWN0czsgdGhvdWdoIFdIQVRXRydzIFVSTCBvYmplY3RzXG5cdFx0XHRcdC8vIHdpbGwgZmFsbCBpbnRvIHRoaXMgYnJhbmNoIGFsc28gKHNpbmNlIHRoZWlyIGB0b1N0cmluZygpYCB3aWxsIHJldHVyblxuXHRcdFx0XHQvLyBgaHJlZmAgcHJvcGVydHkgYW55d2F5KVxuXHRcdFx0XHRwYXJzZWRVUkwgPSBwYXJzZVVSTChpbnB1dC5ocmVmKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGNvZXJjZSBpbnB1dCB0byBhIHN0cmluZyBiZWZvcmUgYXR0ZW1wdGluZyB0byBwYXJzZVxuXHRcdFx0XHRwYXJzZWRVUkwgPSBwYXJzZVVSTChgJHtpbnB1dH1gKTtcblx0XHRcdH1cblx0XHRcdGlucHV0ID0ge307XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhcnNlZFVSTCA9IHBhcnNlVVJMKGlucHV0LnVybCk7XG5cdFx0fVxuXG5cdFx0bGV0IG1ldGhvZCA9IGluaXQubWV0aG9kIHx8IGlucHV0Lm1ldGhvZCB8fCAnR0VUJztcblx0XHRtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcblxuXHRcdGlmICgoaW5pdC5ib2R5ICE9IG51bGwgfHwgaXNSZXF1ZXN0KGlucHV0KSAmJiBpbnB1dC5ib2R5ICE9PSBudWxsKSAmJiAobWV0aG9kID09PSAnR0VUJyB8fCBtZXRob2QgPT09ICdIRUFEJykpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlcXVlc3Qgd2l0aCBHRVQvSEVBRCBtZXRob2QgY2Fubm90IGhhdmUgYm9keScpO1xuXHRcdH1cblxuXHRcdGxldCBpbnB1dEJvZHkgPSBpbml0LmJvZHkgIT0gbnVsbCA/IGluaXQuYm9keSA6IGlzUmVxdWVzdChpbnB1dCkgJiYgaW5wdXQuYm9keSAhPT0gbnVsbCA/IGNsb25lKGlucHV0KSA6IG51bGw7XG5cblx0XHRCb2R5LmNhbGwodGhpcywgaW5wdXRCb2R5LCB7XG5cdFx0XHR0aW1lb3V0OiBpbml0LnRpbWVvdXQgfHwgaW5wdXQudGltZW91dCB8fCAwLFxuXHRcdFx0c2l6ZTogaW5pdC5zaXplIHx8IGlucHV0LnNpemUgfHwgMFxuXHRcdH0pO1xuXG5cdFx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQuaGVhZGVycyB8fCBpbnB1dC5oZWFkZXJzIHx8IHt9KTtcblxuXHRcdGlmIChpbnB1dEJvZHkgIT0gbnVsbCAmJiAhaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpKSB7XG5cdFx0XHRjb25zdCBjb250ZW50VHlwZSA9IGV4dHJhY3RDb250ZW50VHlwZShpbnB1dEJvZHkpO1xuXHRcdFx0aWYgKGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHNpZ25hbCA9IGlzUmVxdWVzdChpbnB1dCkgPyBpbnB1dC5zaWduYWwgOiBudWxsO1xuXHRcdGlmICgnc2lnbmFsJyBpbiBpbml0KSBzaWduYWwgPSBpbml0LnNpZ25hbDtcblxuXHRcdGlmIChzaWduYWwgIT0gbnVsbCAmJiAhaXNBYm9ydFNpZ25hbChzaWduYWwpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBzaWduYWwgdG8gYmUgYW4gaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCcpO1xuXHRcdH1cblxuXHRcdHRoaXNbSU5URVJOQUxTJDJdID0ge1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0cmVkaXJlY3Q6IGluaXQucmVkaXJlY3QgfHwgaW5wdXQucmVkaXJlY3QgfHwgJ2ZvbGxvdycsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0cGFyc2VkVVJMLFxuXHRcdFx0c2lnbmFsXG5cdFx0fTtcblxuXHRcdC8vIG5vZGUtZmV0Y2gtb25seSBvcHRpb25zXG5cdFx0dGhpcy5mb2xsb3cgPSBpbml0LmZvbGxvdyAhPT0gdW5kZWZpbmVkID8gaW5pdC5mb2xsb3cgOiBpbnB1dC5mb2xsb3cgIT09IHVuZGVmaW5lZCA/IGlucHV0LmZvbGxvdyA6IDIwO1xuXHRcdHRoaXMuY29tcHJlc3MgPSBpbml0LmNvbXByZXNzICE9PSB1bmRlZmluZWQgPyBpbml0LmNvbXByZXNzIDogaW5wdXQuY29tcHJlc3MgIT09IHVuZGVmaW5lZCA/IGlucHV0LmNvbXByZXNzIDogdHJ1ZTtcblx0XHR0aGlzLmNvdW50ZXIgPSBpbml0LmNvdW50ZXIgfHwgaW5wdXQuY291bnRlciB8fCAwO1xuXHRcdHRoaXMuYWdlbnQgPSBpbml0LmFnZW50IHx8IGlucHV0LmFnZW50O1xuXHR9XG5cblx0Z2V0IG1ldGhvZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMl0ubWV0aG9kO1xuXHR9XG5cblx0Z2V0IHVybCgpIHtcblx0XHRyZXR1cm4gZm9ybWF0X3VybCh0aGlzW0lOVEVSTkFMUyQyXS5wYXJzZWRVUkwpO1xuXHR9XG5cblx0Z2V0IGhlYWRlcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDJdLmhlYWRlcnM7XG5cdH1cblxuXHRnZXQgcmVkaXJlY3QoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDJdLnJlZGlyZWN0O1xuXHR9XG5cblx0Z2V0IHNpZ25hbCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMl0uc2lnbmFsO1xuXHR9XG5cblx0LyoqXG4gICogQ2xvbmUgdGhpcyByZXF1ZXN0XG4gICpcbiAgKiBAcmV0dXJuICBSZXF1ZXN0XG4gICovXG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgUmVxdWVzdCh0aGlzKTtcblx0fVxufVxuXG5Cb2R5Lm1peEluKFJlcXVlc3QucHJvdG90eXBlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlcXVlc3QucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcblx0dmFsdWU6ICdSZXF1ZXN0Jyxcblx0d3JpdGFibGU6IGZhbHNlLFxuXHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0Y29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVxdWVzdC5wcm90b3R5cGUsIHtcblx0bWV0aG9kOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0dXJsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0aGVhZGVyczogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHJlZGlyZWN0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0Y2xvbmU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRzaWduYWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgUmVxdWVzdCB0byBOb2RlLmpzIGh0dHAgcmVxdWVzdCBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAgIFJlcXVlc3QgIEEgUmVxdWVzdCBpbnN0YW5jZVxuICogQHJldHVybiAgT2JqZWN0ICAgVGhlIG9wdGlvbnMgb2JqZWN0IHRvIGJlIHBhc3NlZCB0byBodHRwLnJlcXVlc3RcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZVJlcXVlc3RPcHRpb25zKHJlcXVlc3QpIHtcblx0Y29uc3QgcGFyc2VkVVJMID0gcmVxdWVzdFtJTlRFUk5BTFMkMl0ucGFyc2VkVVJMO1xuXHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVxdWVzdFtJTlRFUk5BTFMkMl0uaGVhZGVycyk7XG5cblx0Ly8gZmV0Y2ggc3RlcCAxLjNcblx0aWYgKCFoZWFkZXJzLmhhcygnQWNjZXB0JykpIHtcblx0XHRoZWFkZXJzLnNldCgnQWNjZXB0JywgJyovKicpO1xuXHR9XG5cblx0Ly8gQmFzaWMgZmV0Y2hcblx0aWYgKCFwYXJzZWRVUkwucHJvdG9jb2wgfHwgIXBhcnNlZFVSTC5ob3N0bmFtZSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09ubHkgYWJzb2x1dGUgVVJMcyBhcmUgc3VwcG9ydGVkJyk7XG5cdH1cblxuXHRpZiAoIS9eaHR0cHM/OiQvLnRlc3QocGFyc2VkVVJMLnByb3RvY29sKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09ubHkgSFRUUChTKSBwcm90b2NvbHMgYXJlIHN1cHBvcnRlZCcpO1xuXHR9XG5cblx0aWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3QuYm9keSBpbnN0YW5jZW9mIFN0cmVhbS5SZWFkYWJsZSAmJiAhc3RyZWFtRGVzdHJ1Y3Rpb25TdXBwb3J0ZWQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NhbmNlbGxhdGlvbiBvZiBzdHJlYW1lZCByZXF1ZXN0cyB3aXRoIEFib3J0U2lnbmFsIGlzIG5vdCBzdXBwb3J0ZWQgaW4gbm9kZSA8IDgnKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBzdGVwcyAyLjQtMi43XG5cdGxldCBjb250ZW50TGVuZ3RoVmFsdWUgPSBudWxsO1xuXHRpZiAocmVxdWVzdC5ib2R5ID09IG51bGwgJiYgL14oUE9TVHxQVVQpJC9pLnRlc3QocmVxdWVzdC5tZXRob2QpKSB7XG5cdFx0Y29udGVudExlbmd0aFZhbHVlID0gJzAnO1xuXHR9XG5cdGlmIChyZXF1ZXN0LmJvZHkgIT0gbnVsbCkge1xuXHRcdGNvbnN0IHRvdGFsQnl0ZXMgPSBnZXRUb3RhbEJ5dGVzKHJlcXVlc3QpO1xuXHRcdGlmICh0eXBlb2YgdG90YWxCeXRlcyA9PT0gJ251bWJlcicpIHtcblx0XHRcdGNvbnRlbnRMZW5ndGhWYWx1ZSA9IFN0cmluZyh0b3RhbEJ5dGVzKTtcblx0XHR9XG5cdH1cblx0aWYgKGNvbnRlbnRMZW5ndGhWYWx1ZSkge1xuXHRcdGhlYWRlcnMuc2V0KCdDb250ZW50LUxlbmd0aCcsIGNvbnRlbnRMZW5ndGhWYWx1ZSk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggc3RlcCAyLjExXG5cdGlmICghaGVhZGVycy5oYXMoJ1VzZXItQWdlbnQnKSkge1xuXHRcdGhlYWRlcnMuc2V0KCdVc2VyLUFnZW50JywgJ25vZGUtZmV0Y2gvMS4wICgraHR0cHM6Ly9naXRodWIuY29tL2JpdGlubi9ub2RlLWZldGNoKScpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIHN0ZXAgMi4xNVxuXHRpZiAocmVxdWVzdC5jb21wcmVzcyAmJiAhaGVhZGVycy5oYXMoJ0FjY2VwdC1FbmNvZGluZycpKSB7XG5cdFx0aGVhZGVycy5zZXQoJ0FjY2VwdC1FbmNvZGluZycsICdnemlwLGRlZmxhdGUnKTtcblx0fVxuXG5cdGxldCBhZ2VudCA9IHJlcXVlc3QuYWdlbnQ7XG5cdGlmICh0eXBlb2YgYWdlbnQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRhZ2VudCA9IGFnZW50KHBhcnNlZFVSTCk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmsgZmV0Y2ggc3RlcCA0LjJcblx0Ly8gY2h1bmtlZCBlbmNvZGluZyBpcyBoYW5kbGVkIGJ5IE5vZGUuanNcblxuXHRyZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkVVJMLCB7XG5cdFx0bWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcblx0XHRoZWFkZXJzOiBleHBvcnROb2RlQ29tcGF0aWJsZUhlYWRlcnMoaGVhZGVycyksXG5cdFx0YWdlbnRcblx0fSk7XG59XG5cbi8qKlxuICogYWJvcnQtZXJyb3IuanNcbiAqXG4gKiBBYm9ydEVycm9yIGludGVyZmFjZSBmb3IgY2FuY2VsbGVkIHJlcXVlc3RzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgQWJvcnRFcnJvciBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSAgIFN0cmluZyAgICAgIG1lc3NhZ2UgICAgICBFcnJvciBtZXNzYWdlIGZvciBodW1hblxuICogQHJldHVybiAgQWJvcnRFcnJvclxuICovXG5mdW5jdGlvbiBBYm9ydEVycm9yKG1lc3NhZ2UpIHtcbiAgRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuICB0aGlzLnR5cGUgPSAnYWJvcnRlZCc7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cbiAgLy8gaGlkZSBjdXN0b20gZXJyb3IgaW1wbGVtZW50YXRpb24gZGV0YWlscyBmcm9tIGVuZC11c2Vyc1xuICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbn1cblxuQWJvcnRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5BYm9ydEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFib3J0RXJyb3I7XG5BYm9ydEVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0Fib3J0RXJyb3InO1xuXG5jb25zdCBVUkwkMSA9IFVybC5VUkwgfHwgd2hhdHdnVXJsLlVSTDtcblxuLy8gZml4IGFuIGlzc3VlIHdoZXJlIFwiUGFzc1Rocm91Z2hcIiwgXCJyZXNvbHZlXCIgYXJlbid0IGEgbmFtZWQgZXhwb3J0IGZvciBub2RlIDwxMFxuY29uc3QgUGFzc1Rocm91Z2gkMSA9IFN0cmVhbS5QYXNzVGhyb3VnaDtcblxuY29uc3QgaXNEb21haW5PclN1YmRvbWFpbiA9IGZ1bmN0aW9uIGlzRG9tYWluT3JTdWJkb21haW4oZGVzdGluYXRpb24sIG9yaWdpbmFsKSB7XG5cdGNvbnN0IG9yaWcgPSBuZXcgVVJMJDEob3JpZ2luYWwpLmhvc3RuYW1lO1xuXHRjb25zdCBkZXN0ID0gbmV3IFVSTCQxKGRlc3RpbmF0aW9uKS5ob3N0bmFtZTtcblxuXHRyZXR1cm4gb3JpZyA9PT0gZGVzdCB8fCBvcmlnW29yaWcubGVuZ3RoIC0gZGVzdC5sZW5ndGggLSAxXSA9PT0gJy4nICYmIG9yaWcuZW5kc1dpdGgoZGVzdCk7XG59O1xuXG4vKipcbiAqIGlzU2FtZVByb3RvY29sIHJlcG9ydHMgd2hldGhlciB0aGUgdHdvIHByb3ZpZGVkIFVSTHMgdXNlIHRoZSBzYW1lIHByb3RvY29sLlxuICpcbiAqIEJvdGggZG9tYWlucyBtdXN0IGFscmVhZHkgYmUgaW4gY2Fub25pY2FsIGZvcm0uXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IG9yaWdpbmFsXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IGRlc3RpbmF0aW9uXG4gKi9cbmNvbnN0IGlzU2FtZVByb3RvY29sID0gZnVuY3Rpb24gaXNTYW1lUHJvdG9jb2woZGVzdGluYXRpb24sIG9yaWdpbmFsKSB7XG5cdGNvbnN0IG9yaWcgPSBuZXcgVVJMJDEob3JpZ2luYWwpLnByb3RvY29sO1xuXHRjb25zdCBkZXN0ID0gbmV3IFVSTCQxKGRlc3RpbmF0aW9uKS5wcm90b2NvbDtcblxuXHRyZXR1cm4gb3JpZyA9PT0gZGVzdDtcbn07XG5cbi8qKlxuICogRmV0Y2ggZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gICBNaXhlZCAgICB1cmwgICBBYnNvbHV0ZSB1cmwgb3IgUmVxdWVzdCBpbnN0YW5jZVxuICogQHBhcmFtICAgT2JqZWN0ICAgb3B0cyAgRmV0Y2ggb3B0aW9uc1xuICogQHJldHVybiAgUHJvbWlzZVxuICovXG5mdW5jdGlvbiBmZXRjaCh1cmwsIG9wdHMpIHtcblxuXHQvLyBhbGxvdyBjdXN0b20gcHJvbWlzZVxuXHRpZiAoIWZldGNoLlByb21pc2UpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ25hdGl2ZSBwcm9taXNlIG1pc3NpbmcsIHNldCBmZXRjaC5Qcm9taXNlIHRvIHlvdXIgZmF2b3JpdGUgYWx0ZXJuYXRpdmUnKTtcblx0fVxuXG5cdEJvZHkuUHJvbWlzZSA9IGZldGNoLlByb21pc2U7XG5cblx0Ly8gd3JhcCBodHRwLnJlcXVlc3QgaW50byBmZXRjaFxuXHRyZXR1cm4gbmV3IGZldGNoLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdC8vIGJ1aWxkIHJlcXVlc3Qgb2JqZWN0XG5cdFx0Y29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwgb3B0cyk7XG5cdFx0Y29uc3Qgb3B0aW9ucyA9IGdldE5vZGVSZXF1ZXN0T3B0aW9ucyhyZXF1ZXN0KTtcblxuXHRcdGNvbnN0IHNlbmQgPSAob3B0aW9ucy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBodHRwcyA6IGh0dHApLnJlcXVlc3Q7XG5cdFx0Y29uc3Qgc2lnbmFsID0gcmVxdWVzdC5zaWduYWw7XG5cblx0XHRsZXQgcmVzcG9uc2UgPSBudWxsO1xuXG5cdFx0Y29uc3QgYWJvcnQgPSBmdW5jdGlvbiBhYm9ydCgpIHtcblx0XHRcdGxldCBlcnJvciA9IG5ldyBBYm9ydEVycm9yKCdUaGUgdXNlciBhYm9ydGVkIGEgcmVxdWVzdC4nKTtcblx0XHRcdHJlamVjdChlcnJvcik7XG5cdFx0XHRpZiAocmVxdWVzdC5ib2R5ICYmIHJlcXVlc3QuYm9keSBpbnN0YW5jZW9mIFN0cmVhbS5SZWFkYWJsZSkge1xuXHRcdFx0XHRkZXN0cm95U3RyZWFtKHJlcXVlc3QuYm9keSwgZXJyb3IpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFyZXNwb25zZSB8fCAhcmVzcG9uc2UuYm9keSkgcmV0dXJuO1xuXHRcdFx0cmVzcG9uc2UuYm9keS5lbWl0KCdlcnJvcicsIGVycm9yKTtcblx0XHR9O1xuXG5cdFx0aWYgKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkge1xuXHRcdFx0YWJvcnQoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb25zdCBhYm9ydEFuZEZpbmFsaXplID0gZnVuY3Rpb24gYWJvcnRBbmRGaW5hbGl6ZSgpIHtcblx0XHRcdGFib3J0KCk7XG5cdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdH07XG5cblx0XHQvLyBzZW5kIHJlcXVlc3Rcblx0XHRjb25zdCByZXEgPSBzZW5kKG9wdGlvbnMpO1xuXHRcdGxldCByZXFUaW1lb3V0O1xuXG5cdFx0aWYgKHNpZ25hbCkge1xuXHRcdFx0c2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmluYWxpemUoKSB7XG5cdFx0XHRyZXEuYWJvcnQoKTtcblx0XHRcdGlmIChzaWduYWwpIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QW5kRmluYWxpemUpO1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHJlcVRpbWVvdXQpO1xuXHRcdH1cblxuXHRcdGlmIChyZXF1ZXN0LnRpbWVvdXQpIHtcblx0XHRcdHJlcS5vbmNlKCdzb2NrZXQnLCBmdW5jdGlvbiAoc29ja2V0KSB7XG5cdFx0XHRcdHJlcVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYG5ldHdvcmsgdGltZW91dCBhdDogJHtyZXF1ZXN0LnVybH1gLCAncmVxdWVzdC10aW1lb3V0JykpO1xuXHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdH0sIHJlcXVlc3QudGltZW91dCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGByZXF1ZXN0IHRvICR7cmVxdWVzdC51cmx9IGZhaWxlZCwgcmVhc29uOiAke2Vyci5tZXNzYWdlfWAsICdzeXN0ZW0nLCBlcnIpKTtcblxuXHRcdFx0aWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmJvZHkpIHtcblx0XHRcdFx0ZGVzdHJveVN0cmVhbShyZXNwb25zZS5ib2R5LCBlcnIpO1xuXHRcdFx0fVxuXG5cdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdH0pO1xuXG5cdFx0Zml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmcocmVxLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmJvZHkpIHtcblx0XHRcdFx0ZGVzdHJveVN0cmVhbShyZXNwb25zZS5ib2R5LCBlcnIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0LyogYzggaWdub3JlIG5leHQgMTggKi9cblx0XHRpZiAocGFyc2VJbnQocHJvY2Vzcy52ZXJzaW9uLnN1YnN0cmluZygxKSkgPCAxNCkge1xuXHRcdFx0Ly8gQmVmb3JlIE5vZGUuanMgMTQsIHBpcGVsaW5lKCkgZG9lcyBub3QgZnVsbHkgc3VwcG9ydCBhc3luYyBpdGVyYXRvcnMgYW5kIGRvZXMgbm90IGFsd2F5c1xuXHRcdFx0Ly8gcHJvcGVybHkgaGFuZGxlIHdoZW4gdGhlIHNvY2tldCBjbG9zZS9lbmQgZXZlbnRzIGFyZSBvdXQgb2Ygb3JkZXIuXG5cdFx0XHRyZXEub24oJ3NvY2tldCcsIGZ1bmN0aW9uIChzKSB7XG5cdFx0XHRcdHMuYWRkTGlzdGVuZXIoJ2Nsb3NlJywgZnVuY3Rpb24gKGhhZEVycm9yKSB7XG5cdFx0XHRcdFx0Ly8gaWYgYSBkYXRhIGxpc3RlbmVyIGlzIHN0aWxsIHByZXNlbnQgd2UgZGlkbid0IGVuZCBjbGVhbmx5XG5cdFx0XHRcdFx0Y29uc3QgaGFzRGF0YUxpc3RlbmVyID0gcy5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwO1xuXG5cdFx0XHRcdFx0Ly8gaWYgZW5kIGhhcHBlbmVkIGJlZm9yZSBjbG9zZSBidXQgdGhlIHNvY2tldCBkaWRuJ3QgZW1pdCBhbiBlcnJvciwgZG8gaXQgbm93XG5cdFx0XHRcdFx0aWYgKHJlc3BvbnNlICYmIGhhc0RhdGFMaXN0ZW5lciAmJiAhaGFkRXJyb3IgJiYgIShzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ1ByZW1hdHVyZSBjbG9zZScpO1xuXHRcdFx0XHRcdFx0ZXJyLmNvZGUgPSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnO1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UuYm9keS5lbWl0KCdlcnJvcicsIGVycik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJlcS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAocmVzKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQocmVxVGltZW91dCk7XG5cblx0XHRcdGNvbnN0IGhlYWRlcnMgPSBjcmVhdGVIZWFkZXJzTGVuaWVudChyZXMuaGVhZGVycyk7XG5cblx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1XG5cdFx0XHRpZiAoZmV0Y2guaXNSZWRpcmVjdChyZXMuc3RhdHVzQ29kZSkpIHtcblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuMlxuXHRcdFx0XHRjb25zdCBsb2NhdGlvbiA9IGhlYWRlcnMuZ2V0KCdMb2NhdGlvbicpO1xuXG5cdFx0XHRcdC8vIEhUVFAgZmV0Y2ggc3RlcCA1LjNcblx0XHRcdFx0bGV0IGxvY2F0aW9uVVJMID0gbnVsbDtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRsb2NhdGlvblVSTCA9IGxvY2F0aW9uID09PSBudWxsID8gbnVsbCA6IG5ldyBVUkwkMShsb2NhdGlvbiwgcmVxdWVzdC51cmwpLnRvU3RyaW5nKCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdC8vIGVycm9yIGhlcmUgY2FuIG9ubHkgYmUgaW52YWxpZCBVUkwgaW4gTG9jYXRpb246IGhlYWRlclxuXHRcdFx0XHRcdC8vIGRvIG5vdCB0aHJvdyB3aGVuIG9wdGlvbnMucmVkaXJlY3QgPT0gbWFudWFsXG5cdFx0XHRcdFx0Ly8gbGV0IHRoZSB1c2VyIGV4dHJhY3QgdGhlIGVycm9ybmVvdXMgcmVkaXJlY3QgVVJMXG5cdFx0XHRcdFx0aWYgKHJlcXVlc3QucmVkaXJlY3QgIT09ICdtYW51YWwnKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYHVyaSByZXF1ZXN0ZWQgcmVzcG9uZHMgd2l0aCBhbiBpbnZhbGlkIHJlZGlyZWN0IFVSTDogJHtsb2NhdGlvbn1gLCAnaW52YWxpZC1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuNVxuXHRcdFx0XHRzd2l0Y2ggKHJlcXVlc3QucmVkaXJlY3QpIHtcblx0XHRcdFx0XHRjYXNlICdlcnJvcic6XG5cdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYHVyaSByZXF1ZXN0ZWQgcmVzcG9uZHMgd2l0aCBhIHJlZGlyZWN0LCByZWRpcmVjdCBtb2RlIGlzIHNldCB0byBlcnJvcjogJHtyZXF1ZXN0LnVybH1gLCAnbm8tcmVkaXJlY3QnKSk7XG5cdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdGNhc2UgJ21hbnVhbCc6XG5cdFx0XHRcdFx0XHQvLyBub2RlLWZldGNoLXNwZWNpZmljIHN0ZXA6IG1ha2UgbWFudWFsIHJlZGlyZWN0IGEgYml0IGVhc2llciB0byB1c2UgYnkgc2V0dGluZyB0aGUgTG9jYXRpb24gaGVhZGVyIHZhbHVlIHRvIHRoZSByZXNvbHZlZCBVUkwuXG5cdFx0XHRcdFx0XHRpZiAobG9jYXRpb25VUkwgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0Ly8gaGFuZGxlIGNvcnJ1cHRlZCBoZWFkZXJcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRoZWFkZXJzLnNldCgnTG9jYXRpb24nLCBsb2NhdGlvblVSTCk7XG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBub2RlanMgc2VydmVyIHByZXZlbnQgaW52YWxpZCByZXNwb25zZSBoZWFkZXJzLCB3ZSBjYW4ndCB0ZXN0IHRoaXMgdGhyb3VnaCBub3JtYWwgcmVxdWVzdFxuXHRcdFx0XHRcdFx0XHRcdHJlamVjdChlcnIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdmb2xsb3cnOlxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDJcblx0XHRcdFx0XHRcdGlmIChsb2NhdGlvblVSTCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDVcblx0XHRcdFx0XHRcdGlmIChyZXF1ZXN0LmNvdW50ZXIgPj0gcmVxdWVzdC5mb2xsb3cpIHtcblx0XHRcdFx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBtYXhpbXVtIHJlZGlyZWN0IHJlYWNoZWQgYXQ6ICR7cmVxdWVzdC51cmx9YCwgJ21heC1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgNiAoY291bnRlciBpbmNyZW1lbnQpXG5cdFx0XHRcdFx0XHQvLyBDcmVhdGUgYSBuZXcgUmVxdWVzdCBvYmplY3QuXG5cdFx0XHRcdFx0XHRjb25zdCByZXF1ZXN0T3B0cyA9IHtcblx0XHRcdFx0XHRcdFx0aGVhZGVyczogbmV3IEhlYWRlcnMocmVxdWVzdC5oZWFkZXJzKSxcblx0XHRcdFx0XHRcdFx0Zm9sbG93OiByZXF1ZXN0LmZvbGxvdyxcblx0XHRcdFx0XHRcdFx0Y291bnRlcjogcmVxdWVzdC5jb3VudGVyICsgMSxcblx0XHRcdFx0XHRcdFx0YWdlbnQ6IHJlcXVlc3QuYWdlbnQsXG5cdFx0XHRcdFx0XHRcdGNvbXByZXNzOiByZXF1ZXN0LmNvbXByZXNzLFxuXHRcdFx0XHRcdFx0XHRtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuXHRcdFx0XHRcdFx0XHRib2R5OiByZXF1ZXN0LmJvZHksXG5cdFx0XHRcdFx0XHRcdHNpZ25hbDogcmVxdWVzdC5zaWduYWwsXG5cdFx0XHRcdFx0XHRcdHRpbWVvdXQ6IHJlcXVlc3QudGltZW91dCxcblx0XHRcdFx0XHRcdFx0c2l6ZTogcmVxdWVzdC5zaXplXG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRpZiAoIWlzRG9tYWluT3JTdWJkb21haW4ocmVxdWVzdC51cmwsIGxvY2F0aW9uVVJMKSB8fCAhaXNTYW1lUHJvdG9jb2wocmVxdWVzdC51cmwsIGxvY2F0aW9uVVJMKSkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgWydhdXRob3JpemF0aW9uJywgJ3d3dy1hdXRoZW50aWNhdGUnLCAnY29va2llJywgJ2Nvb2tpZTInXSkge1xuXHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRzLmhlYWRlcnMuZGVsZXRlKG5hbWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCA5XG5cdFx0XHRcdFx0XHRpZiAocmVzLnN0YXR1c0NvZGUgIT09IDMwMyAmJiByZXF1ZXN0LmJvZHkgJiYgZ2V0VG90YWxCeXRlcyhyZXF1ZXN0KSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoJ0Nhbm5vdCBmb2xsb3cgcmVkaXJlY3Qgd2l0aCBib2R5IGJlaW5nIGEgcmVhZGFibGUgc3RyZWFtJywgJ3Vuc3VwcG9ydGVkLXJlZGlyZWN0JykpO1xuXHRcdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAxMVxuXHRcdFx0XHRcdFx0aWYgKHJlcy5zdGF0dXNDb2RlID09PSAzMDMgfHwgKHJlcy5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDMwMikgJiYgcmVxdWVzdC5tZXRob2QgPT09ICdQT1NUJykge1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0cy5tZXRob2QgPSAnR0VUJztcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdHMuYm9keSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdHMuaGVhZGVycy5kZWxldGUoJ2NvbnRlbnQtbGVuZ3RoJyk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCAxNVxuXHRcdFx0XHRcdFx0cmVzb2x2ZShmZXRjaChuZXcgUmVxdWVzdChsb2NhdGlvblVSTCwgcmVxdWVzdE9wdHMpKSk7XG5cdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByZXBhcmUgcmVzcG9uc2Vcblx0XHRcdHJlcy5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChzaWduYWwpIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QW5kRmluYWxpemUpO1xuXHRcdFx0fSk7XG5cdFx0XHRsZXQgYm9keSA9IHJlcy5waXBlKG5ldyBQYXNzVGhyb3VnaCQxKCkpO1xuXG5cdFx0XHRjb25zdCByZXNwb25zZV9vcHRpb25zID0ge1xuXHRcdFx0XHR1cmw6IHJlcXVlc3QudXJsLFxuXHRcdFx0XHRzdGF0dXM6IHJlcy5zdGF0dXNDb2RlLFxuXHRcdFx0XHRzdGF0dXNUZXh0OiByZXMuc3RhdHVzTWVzc2FnZSxcblx0XHRcdFx0aGVhZGVyczogaGVhZGVycyxcblx0XHRcdFx0c2l6ZTogcmVxdWVzdC5zaXplLFxuXHRcdFx0XHR0aW1lb3V0OiByZXF1ZXN0LnRpbWVvdXQsXG5cdFx0XHRcdGNvdW50ZXI6IHJlcXVlc3QuY291bnRlclxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gSFRUUC1uZXR3b3JrIGZldGNoIHN0ZXAgMTIuMS4xLjNcblx0XHRcdGNvbnN0IGNvZGluZ3MgPSBoZWFkZXJzLmdldCgnQ29udGVudC1FbmNvZGluZycpO1xuXG5cdFx0XHQvLyBIVFRQLW5ldHdvcmsgZmV0Y2ggc3RlcCAxMi4xLjEuNDogaGFuZGxlIGNvbnRlbnQgY29kaW5nc1xuXG5cdFx0XHQvLyBpbiBmb2xsb3dpbmcgc2NlbmFyaW9zIHdlIGlnbm9yZSBjb21wcmVzc2lvbiBzdXBwb3J0XG5cdFx0XHQvLyAxLiBjb21wcmVzc2lvbiBzdXBwb3J0IGlzIGRpc2FibGVkXG5cdFx0XHQvLyAyLiBIRUFEIHJlcXVlc3Rcblx0XHRcdC8vIDMuIG5vIENvbnRlbnQtRW5jb2RpbmcgaGVhZGVyXG5cdFx0XHQvLyA0LiBubyBjb250ZW50IHJlc3BvbnNlICgyMDQpXG5cdFx0XHQvLyA1LiBjb250ZW50IG5vdCBtb2RpZmllZCByZXNwb25zZSAoMzA0KVxuXHRcdFx0aWYgKCFyZXF1ZXN0LmNvbXByZXNzIHx8IHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcgfHwgY29kaW5ncyA9PT0gbnVsbCB8fCByZXMuc3RhdHVzQ29kZSA9PT0gMjA0IHx8IHJlcy5zdGF0dXNDb2RlID09PSAzMDQpIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2Vfb3B0aW9ucyk7XG5cdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBOb2RlIHY2K1xuXHRcdFx0Ly8gQmUgbGVzcyBzdHJpY3Qgd2hlbiBkZWNvZGluZyBjb21wcmVzc2VkIHJlc3BvbnNlcywgc2luY2Ugc29tZXRpbWVzXG5cdFx0XHQvLyBzZXJ2ZXJzIHNlbmQgc2xpZ2h0bHkgaW52YWxpZCByZXNwb25zZXMgdGhhdCBhcmUgc3RpbGwgYWNjZXB0ZWRcblx0XHRcdC8vIGJ5IGNvbW1vbiBicm93c2Vycy5cblx0XHRcdC8vIEFsd2F5cyB1c2luZyBaX1NZTkNfRkxVU0ggaXMgd2hhdCBjVVJMIGRvZXMuXG5cdFx0XHRjb25zdCB6bGliT3B0aW9ucyA9IHtcblx0XHRcdFx0Zmx1c2g6IHpsaWIuWl9TWU5DX0ZMVVNILFxuXHRcdFx0XHRmaW5pc2hGbHVzaDogemxpYi5aX1NZTkNfRkxVU0hcblx0XHRcdH07XG5cblx0XHRcdC8vIGZvciBnemlwXG5cdFx0XHRpZiAoY29kaW5ncyA9PSAnZ3ppcCcgfHwgY29kaW5ncyA9PSAneC1nemlwJykge1xuXHRcdFx0XHRib2R5ID0gYm9keS5waXBlKHpsaWIuY3JlYXRlR3VuemlwKHpsaWJPcHRpb25zKSk7XG5cdFx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlX29wdGlvbnMpO1xuXHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBmb3IgZGVmbGF0ZVxuXHRcdFx0aWYgKGNvZGluZ3MgPT0gJ2RlZmxhdGUnIHx8IGNvZGluZ3MgPT0gJ3gtZGVmbGF0ZScpIHtcblx0XHRcdFx0Ly8gaGFuZGxlIHRoZSBpbmZhbW91cyByYXcgZGVmbGF0ZSByZXNwb25zZSBmcm9tIG9sZCBzZXJ2ZXJzXG5cdFx0XHRcdC8vIGEgaGFjayBmb3Igb2xkIElJUyBhbmQgQXBhY2hlIHNlcnZlcnNcblx0XHRcdFx0Y29uc3QgcmF3ID0gcmVzLnBpcGUobmV3IFBhc3NUaHJvdWdoJDEoKSk7XG5cdFx0XHRcdHJhdy5vbmNlKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG5cdFx0XHRcdFx0Ly8gc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzc1MTk4Mjhcblx0XHRcdFx0XHRpZiAoKGNodW5rWzBdICYgMHgwRikgPT09IDB4MDgpIHtcblx0XHRcdFx0XHRcdGJvZHkgPSBib2R5LnBpcGUoemxpYi5jcmVhdGVJbmZsYXRlKCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRib2R5ID0gYm9keS5waXBlKHpsaWIuY3JlYXRlSW5mbGF0ZVJhdygpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2Vfb3B0aW9ucyk7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyYXcub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQvLyBzb21lIG9sZCBJSVMgc2VydmVycyByZXR1cm4gemVyby1sZW5ndGggT0sgZGVmbGF0ZSByZXNwb25zZXMsIHNvICdkYXRhJyBpcyBuZXZlciBlbWl0dGVkLlxuXHRcdFx0XHRcdGlmICghcmVzcG9uc2UpIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlX29wdGlvbnMpO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBmb3IgYnJcblx0XHRcdGlmIChjb2RpbmdzID09ICdicicgJiYgdHlwZW9mIHpsaWIuY3JlYXRlQnJvdGxpRGVjb21wcmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRib2R5ID0gYm9keS5waXBlKHpsaWIuY3JlYXRlQnJvdGxpRGVjb21wcmVzcygpKTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2Vfb3B0aW9ucyk7XG5cdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIG90aGVyd2lzZSwgdXNlIHJlc3BvbnNlIGFzLWlzXG5cdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZV9vcHRpb25zKTtcblx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdH0pO1xuXG5cdFx0d3JpdGVUb1N0cmVhbShyZXEsIHJlcXVlc3QpO1xuXHR9KTtcbn1cbmZ1bmN0aW9uIGZpeFJlc3BvbnNlQ2h1bmtlZFRyYW5zZmVyQmFkRW5kaW5nKHJlcXVlc3QsIGVycm9yQ2FsbGJhY2spIHtcblx0bGV0IHNvY2tldDtcblxuXHRyZXF1ZXN0Lm9uKCdzb2NrZXQnLCBmdW5jdGlvbiAocykge1xuXHRcdHNvY2tldCA9IHM7XG5cdH0pO1xuXG5cdHJlcXVlc3Qub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdFx0Y29uc3QgaGVhZGVycyA9IHJlc3BvbnNlLmhlYWRlcnM7XG5cblx0XHRpZiAoaGVhZGVyc1sndHJhbnNmZXItZW5jb2RpbmcnXSA9PT0gJ2NodW5rZWQnICYmICFoZWFkZXJzWydjb250ZW50LWxlbmd0aCddKSB7XG5cdFx0XHRyZXNwb25zZS5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIChoYWRFcnJvcikge1xuXHRcdFx0XHQvLyB0ZXN0cyBmb3Igc29ja2V0IHByZXNlbmNlLCBhcyBpbiBzb21lIHNpdHVhdGlvbnMgdGhlXG5cdFx0XHRcdC8vIHRoZSAnc29ja2V0JyBldmVudCBpcyBub3QgdHJpZ2dlcmVkIGZvciB0aGUgcmVxdWVzdFxuXHRcdFx0XHQvLyAoaGFwcGVucyBpbiBkZW5vKSwgYXZvaWRzIGBUeXBlRXJyb3JgXG5cdFx0XHRcdC8vIGlmIGEgZGF0YSBsaXN0ZW5lciBpcyBzdGlsbCBwcmVzZW50IHdlIGRpZG4ndCBlbmQgY2xlYW5seVxuXHRcdFx0XHRjb25zdCBoYXNEYXRhTGlzdGVuZXIgPSBzb2NrZXQgJiYgc29ja2V0Lmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDA7XG5cblx0XHRcdFx0aWYgKGhhc0RhdGFMaXN0ZW5lciAmJiAhaGFkRXJyb3IpIHtcblx0XHRcdFx0XHRjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ1ByZW1hdHVyZSBjbG9zZScpO1xuXHRcdFx0XHRcdGVyci5jb2RlID0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJztcblx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKGVycik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lTdHJlYW0oc3RyZWFtLCBlcnIpIHtcblx0aWYgKHN0cmVhbS5kZXN0cm95KSB7XG5cdFx0c3RyZWFtLmRlc3Ryb3koZXJyKTtcblx0fSBlbHNlIHtcblx0XHQvLyBub2RlIDwgOFxuXHRcdHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG5cdFx0c3RyZWFtLmVuZCgpO1xuXHR9XG59XG5cbi8qKlxuICogUmVkaXJlY3QgY29kZSBtYXRjaGluZ1xuICpcbiAqIEBwYXJhbSAgIE51bWJlciAgIGNvZGUgIFN0YXR1cyBjb2RlXG4gKiBAcmV0dXJuICBCb29sZWFuXG4gKi9cbmZldGNoLmlzUmVkaXJlY3QgPSBmdW5jdGlvbiAoY29kZSkge1xuXHRyZXR1cm4gY29kZSA9PT0gMzAxIHx8IGNvZGUgPT09IDMwMiB8fCBjb2RlID09PSAzMDMgfHwgY29kZSA9PT0gMzA3IHx8IGNvZGUgPT09IDMwODtcbn07XG5cbi8vIGV4cG9zZSBQcm9taXNlXG5mZXRjaC5Qcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG5cbmV4cG9ydCBkZWZhdWx0IGZldGNoO1xuZXhwb3J0IHsgSGVhZGVycywgUmVxdWVzdCwgUmVzcG9uc2UsIEZldGNoRXJyb3IsIEFib3J0RXJyb3IgfTtcbiJdLCJuYW1lcyI6WyJTdHJlYW0iLCJodHRwIiwiVXJsIiwid2hhdHdnVXJsIiwiaHR0cHMiLCJ6bGliIiwiUmVhZGFibGUiLCJCVUZGRVIiLCJTeW1ib2wiLCJUWVBFIiwiQmxvYiIsImNvbnN0cnVjdG9yIiwiYmxvYlBhcnRzIiwiYXJndW1lbnRzIiwib3B0aW9ucyIsImJ1ZmZlcnMiLCJzaXplIiwiYSIsImxlbmd0aCIsIk51bWJlciIsImkiLCJlbGVtZW50IiwiYnVmZmVyIiwiQnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJmcm9tIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJTdHJpbmciLCJwdXNoIiwiY29uY2F0IiwidHlwZSIsInVuZGVmaW5lZCIsInRvTG93ZXJDYXNlIiwidGVzdCIsInRleHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRvU3RyaW5nIiwiYXJyYXlCdWZmZXIiLCJidWYiLCJhYiIsInNsaWNlIiwic3RyZWFtIiwicmVhZGFibGUiLCJfcmVhZCIsInN0YXJ0IiwiZW5kIiwicmVsYXRpdmVTdGFydCIsInJlbGF0aXZlRW5kIiwiTWF0aCIsIm1heCIsIm1pbiIsInNwYW4iLCJzbGljZWRCdWZmZXIiLCJibG9iIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsIkZldGNoRXJyb3IiLCJtZXNzYWdlIiwic3lzdGVtRXJyb3IiLCJFcnJvciIsImNhbGwiLCJjb2RlIiwiZXJybm8iLCJjYXB0dXJlU3RhY2tUcmFjZSIsImNyZWF0ZSIsIm5hbWUiLCJjb252ZXJ0IiwicmVxdWlyZSIsImUiLCJJTlRFUk5BTFMiLCJQYXNzVGhyb3VnaCIsIkJvZHkiLCJib2R5IiwiX3RoaXMiLCJfcmVmIiwiX3JlZiRzaXplIiwiX3JlZiR0aW1lb3V0IiwidGltZW91dCIsImlzVVJMU2VhcmNoUGFyYW1zIiwiaXNCbG9iIiwiaXNCdWZmZXIiLCJkaXN0dXJiZWQiLCJlcnJvciIsIm9uIiwiZXJyIiwidXJsIiwiYm9keVVzZWQiLCJjb25zdW1lQm9keSIsInRoZW4iLCJjdCIsImhlYWRlcnMiLCJnZXQiLCJhc3NpZ24iLCJqc29uIiwiX3RoaXMyIiwiSlNPTiIsInBhcnNlIiwicmVqZWN0IiwidGV4dENvbnZlcnRlZCIsIl90aGlzMyIsImNvbnZlcnRCb2R5IiwibWl4SW4iLCJwcm90byIsImdldE93blByb3BlcnR5TmFtZXMiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX3RoaXM0IiwiVHlwZUVycm9yIiwiYWxsb2MiLCJhY2N1bSIsImFjY3VtQnl0ZXMiLCJhYm9ydCIsInJlc1RpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2h1bmsiLCJjbGVhclRpbWVvdXQiLCJjaGFyc2V0IiwicmVzIiwic3RyIiwiZXhlYyIsInBvcCIsIm9iaiIsImFwcGVuZCIsImRlbGV0ZSIsImdldEFsbCIsImhhcyIsInNldCIsInNvcnQiLCJjbG9uZSIsImluc3RhbmNlIiwicDEiLCJwMiIsImdldEJvdW5kYXJ5IiwicGlwZSIsImV4dHJhY3RDb250ZW50VHlwZSIsImdldFRvdGFsQnl0ZXMiLCJnZXRMZW5ndGhTeW5jIiwiX2xlbmd0aFJldHJpZXZlcnMiLCJoYXNLbm93bkxlbmd0aCIsIndyaXRlVG9TdHJlYW0iLCJkZXN0Iiwid3JpdGUiLCJnbG9iYWwiLCJpbnZhbGlkVG9rZW5SZWdleCIsImludmFsaWRIZWFkZXJDaGFyUmVnZXgiLCJ2YWxpZGF0ZU5hbWUiLCJ2YWxpZGF0ZVZhbHVlIiwiZmluZCIsIm1hcCIsImtleSIsIk1BUCIsIkhlYWRlcnMiLCJpbml0IiwicmF3SGVhZGVycyIsInJhdyIsImhlYWRlck5hbWVzIiwia2V5cyIsImhlYWRlck5hbWUiLCJtZXRob2QiLCJpdGVyYXRvciIsInBhaXJzIiwicGFpciIsIkFycmF5Iiwiam9pbiIsImZvckVhY2giLCJjYWxsYmFjayIsInRoaXNBcmciLCJnZXRIZWFkZXJzIiwiX3BhaXJzJGkiLCJjcmVhdGVIZWFkZXJzSXRlcmF0b3IiLCJ2YWx1ZXMiLCJlbnRyaWVzIiwia2luZCIsImsiLCJJTlRFUk5BTCIsInRhcmdldCIsIkhlYWRlcnNJdGVyYXRvclByb3RvdHlwZSIsImluZGV4Iiwic2V0UHJvdG90eXBlT2YiLCJuZXh0IiwiZ2V0UHJvdG90eXBlT2YiLCJfSU5URVJOQUwiLCJsZW4iLCJkb25lIiwiZXhwb3J0Tm9kZUNvbXBhdGlibGVIZWFkZXJzIiwiX19wcm90b19fIiwiaG9zdEhlYWRlcktleSIsImNyZWF0ZUhlYWRlcnNMZW5pZW50IiwiaXNBcnJheSIsInZhbCIsIklOVEVSTkFMUyQxIiwiU1RBVFVTX0NPREVTIiwiUmVzcG9uc2UiLCJvcHRzIiwic3RhdHVzIiwiY29udGVudFR5cGUiLCJzdGF0dXNUZXh0IiwiY291bnRlciIsIm9rIiwicmVkaXJlY3RlZCIsIklOVEVSTkFMUyQyIiwiVVJMIiwicGFyc2VfdXJsIiwiZm9ybWF0X3VybCIsImZvcm1hdCIsInBhcnNlVVJMIiwidXJsU3RyIiwic3RyZWFtRGVzdHJ1Y3Rpb25TdXBwb3J0ZWQiLCJpc1JlcXVlc3QiLCJpbnB1dCIsImlzQWJvcnRTaWduYWwiLCJzaWduYWwiLCJSZXF1ZXN0IiwicGFyc2VkVVJMIiwiaHJlZiIsInRvVXBwZXJDYXNlIiwiaW5wdXRCb2R5IiwicmVkaXJlY3QiLCJmb2xsb3ciLCJjb21wcmVzcyIsImFnZW50IiwiZ2V0Tm9kZVJlcXVlc3RPcHRpb25zIiwicmVxdWVzdCIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJjb250ZW50TGVuZ3RoVmFsdWUiLCJ0b3RhbEJ5dGVzIiwiQWJvcnRFcnJvciIsIlVSTCQxIiwiUGFzc1Rocm91Z2gkMSIsImlzRG9tYWluT3JTdWJkb21haW4iLCJkZXN0aW5hdGlvbiIsIm9yaWdpbmFsIiwib3JpZyIsImVuZHNXaXRoIiwiaXNTYW1lUHJvdG9jb2wiLCJmZXRjaCIsInNlbmQiLCJyZXNwb25zZSIsImRlc3Ryb3lTdHJlYW0iLCJlbWl0IiwiYWJvcnRlZCIsImFib3J0QW5kRmluYWxpemUiLCJmaW5hbGl6ZSIsInJlcSIsInJlcVRpbWVvdXQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJzb2NrZXQiLCJmaXhSZXNwb25zZUNodW5rZWRUcmFuc2ZlckJhZEVuZGluZyIsInBhcnNlSW50IiwicHJvY2VzcyIsInZlcnNpb24iLCJzdWJzdHJpbmciLCJzIiwiYWRkTGlzdGVuZXIiLCJoYWRFcnJvciIsImhhc0RhdGFMaXN0ZW5lciIsImxpc3RlbmVyQ291bnQiLCJpc1JlZGlyZWN0Iiwic3RhdHVzQ29kZSIsImxvY2F0aW9uIiwibG9jYXRpb25VUkwiLCJyZXF1ZXN0T3B0cyIsInJlc3BvbnNlX29wdGlvbnMiLCJzdGF0dXNNZXNzYWdlIiwiY29kaW5ncyIsInpsaWJPcHRpb25zIiwiZmx1c2giLCJaX1NZTkNfRkxVU0giLCJmaW5pc2hGbHVzaCIsImNyZWF0ZUd1bnppcCIsImNyZWF0ZUluZmxhdGUiLCJjcmVhdGVJbmZsYXRlUmF3IiwiY3JlYXRlQnJvdGxpRGVjb21wcmVzcyIsImVycm9yQ2FsbGJhY2siLCJkZXN0cm95Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/node-fetch/lib/index.mjs\n");

/***/ })

};
;