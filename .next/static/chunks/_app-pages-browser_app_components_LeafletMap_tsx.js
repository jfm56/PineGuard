"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_app_components_LeafletMap_tsx"],{

/***/ "(app-pages-browser)/./app/components/LeafletMap.tsx":
/*!***************************************!*\
  !*** ./app/components/LeafletMap.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ LeafletMap; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _MapLayers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MapLayers */ \"(app-pages-browser)/./app/components/MapLayers.tsx\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ var _s = $RefreshSig$();\nvar _s1 = $RefreshSig$();\n\n\n\nfunction LeafletMap() {\n    _s();\n    _s1();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const layersRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        fireRisk: null,\n        evacuationRoutes: null,\n        fireStations: null,\n        waterSources: null\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var // Add event listeners\n        _document_getElementById, _document_getElementById1, _document_getElementById2, _document_getElementById3, _document_getElementById4;\n        // Wait for Leaflet to be available\n        if ( false || !window.L) {\n            console.error(\"Leaflet not loaded\");\n            return;\n        }\n        // Initialize map\n        const map = window.L.map(\"map\").setView([\n            39.8,\n            -74.5\n        ], 9);\n        mapRef.current = map;\n        // Add OpenStreetMap tiles\n        window.L.tileLayer(\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\", {\n            attribution: \"\\xa9 OpenStreetMap contributors\"\n        }).addTo(map);\n        // Initialize layer groups\n        const layers = {\n            fireRisk: window.L.layerGroup().addTo(map),\n            evacuationRoutes: window.L.layerGroup(),\n            fireStations: window.L.layerGroup(),\n            waterSources: window.L.layerGroup()\n        };\n        layersRef.current = layers;\n        // Initialize icons\n        const icons = {\n            fireStation: window.L.icon({\n                iconUrl: \"/static/icons/fire-station.png\",\n                iconSize: [\n                    32,\n                    32\n                ],\n                iconAnchor: [\n                    16,\n                    32\n                ],\n                popupAnchor: [\n                    0,\n                    -32\n                ]\n            }),\n            waterSource: window.L.icon({\n                iconUrl: \"/static/icons/water-source.png\",\n                iconSize: [\n                    32,\n                    32\n                ],\n                iconAnchor: [\n                    16,\n                    32\n                ],\n                popupAnchor: [\n                    0,\n                    -32\n                ]\n            })\n        };\n        // Load initial map data\n        const loadMapData = async ()=>{\n            try {\n                const response = await fetch(\"/api/map-data\");\n                const data = await response.json();\n                // Add fire stations\n                data.fireStations.forEach((station)=>{\n                    window.L.marker(station.coords, {\n                        icon: icons.fireStation\n                    }).bindPopup(\"<b>\".concat(station.name, \"</b>\")).addTo(layers.fireStations);\n                });\n                // Add water sources\n                data.waterSources.forEach((source)=>{\n                    window.L.marker(source.coords, {\n                        icon: icons.waterSource\n                    }).bindPopup(\"<b>\".concat(source.name, \"</b>\")).addTo(layers.waterSources);\n                });\n                // Add evacuation routes\n                data.evacuationRoutes.forEach((route)=>{\n                    window.L.polyline(route.path, {\n                        color: \"blue\",\n                        weight: 3,\n                        opacity: 0.7\n                    }).bindPopup(\"<b>\".concat(route.name, \"</b>\")).addTo(layers.evacuationRoutes);\n                });\n                // Initial risk areas update\n                updateRiskAreas();\n            } catch (error) {\n                console.error(\"Error loading map data:\", error);\n            }\n        };\n        // Update risk areas\n        const updateRiskAreas = async ()=>{\n            try {\n                var _document_getElementById;\n                const timeRange = ((_document_getElementById = document.getElementById(\"timeRange\")) === null || _document_getElementById === void 0 ? void 0 : _document_getElementById.value) || \"24h\";\n                layers.fireRisk.clearLayers();\n                const response = await fetch(\"/api/fire-risk?timeRange=\".concat(timeRange));\n                const data = await response.json();\n                // Adjust risk levels based on weather\n                // Get current weather data first\n                const weatherResponse = await fetch(\"/api/current-weather\");\n                const currentWeather = await weatherResponse.json();\n                data.riskAreas.forEach((area)=>{\n                    // Use current weather data to update risk levels\n                    const windSpeed = currentWeather.windSpeed;\n                    const humidity = currentWeather.humidity;\n                    // Update area's weather factors\n                    area.factors = [\n                        {\n                            name: \"Temperature\",\n                            value: \"\".concat(currentWeather.temperature, \"\\xb0F\")\n                        },\n                        {\n                            name: \"Wind Speed\",\n                            value: \"\".concat(windSpeed, \" mph \").concat(currentWeather.windDirection)\n                        },\n                        {\n                            name: \"Humidity\",\n                            value: \"\".concat(humidity, \"%\")\n                        }\n                    ];\n                    // Adjust risk level based on current conditions\n                    if (humidity < 30 && windSpeed > 15) {\n                        area.riskLevel = \"extreme\";\n                    } else if (humidity < 40 && windSpeed > 10) {\n                        area.riskLevel = \"high\";\n                    } else if (humidity > 60 && currentWeather.temperature < 50) {\n                        area.riskLevel = \"low\";\n                    }\n                    const color = getRiskColor(area.riskLevel);\n                    const radius = area.severity * 1000; // Convert to meters\n                    window.L.circle(area.coords, {\n                        color: color,\n                        fillColor: color,\n                        fillOpacity: 0.4,\n                        radius: radius\n                    }).bindPopup('\\n              <div class=\"p-2\">\\n                <div class=\"font-bold text-lg mb-2 capitalize\">Risk Level: '.concat(area.riskLevel, '</div>\\n                <div class=\"font-bold mt-2\">Current Conditions:</div>\\n                <ul class=\"mt-1\">\\n                  ').concat(area.factors.map((f)=>\"<li>â€¢ \".concat(f.name, \": \").concat(f.value, \"</li>\")).join(\"\"), \"\\n                </ul>\\n              </div>\\n            \"), {\n                        className: \"custom-popup\",\n                        closeButton: true,\n                        autoPan: true\n                    }).addTo(layers.fireRisk);\n                });\n            } catch (error) {\n                console.error(\"Error updating risk areas:\", error);\n            }\n        };\n        // Get color based on risk level\n        const getRiskColor = (riskLevel)=>{\n            switch(riskLevel.toLowerCase()){\n                case \"extreme\":\n                    return \"#ff0000\";\n                case \"high\":\n                    return \"#ff6600\";\n                case \"moderate\":\n                    return \"#ffcc00\";\n                case \"low\":\n                    return \"#00cc00\";\n                default:\n                    return \"#00ff00\";\n            }\n        };\n        (_document_getElementById = document.getElementById(\"fireRiskLayer\")) === null || _document_getElementById === void 0 ? void 0 : _document_getElementById.addEventListener(\"change\", (e)=>{\n            const target = e.target;\n            if (target.checked) {\n                map.addLayer(layers.fireRisk);\n            } else {\n                map.removeLayer(layers.fireRisk);\n            }\n        });\n        (_document_getElementById1 = document.getElementById(\"evacuationRoutes\")) === null || _document_getElementById1 === void 0 ? void 0 : _document_getElementById1.addEventListener(\"change\", (e)=>{\n            const target = e.target;\n            if (target.checked) {\n                map.addLayer(layers.evacuationRoutes);\n            } else {\n                map.removeLayer(layers.evacuationRoutes);\n            }\n        });\n        (_document_getElementById2 = document.getElementById(\"fireStations\")) === null || _document_getElementById2 === void 0 ? void 0 : _document_getElementById2.addEventListener(\"change\", (e)=>{\n            const target = e.target;\n            if (target.checked) {\n                map.addLayer(layers.fireStations);\n            } else {\n                map.removeLayer(layers.fireStations);\n            }\n        });\n        (_document_getElementById3 = document.getElementById(\"waterSources\")) === null || _document_getElementById3 === void 0 ? void 0 : _document_getElementById3.addEventListener(\"change\", (e)=>{\n            const target = e.target;\n            if (target.checked) {\n                map.addLayer(layers.waterSources);\n            } else {\n                map.removeLayer(layers.waterSources);\n            }\n        });\n        (_document_getElementById4 = document.getElementById(\"timeRange\")) === null || _document_getElementById4 === void 0 ? void 0 : _document_getElementById4.addEventListener(\"change\", ()=>{\n            updateRiskAreas();\n        });\n        // Load initial data\n        loadMapData();\n        // Cleanup\n        return ()=>{\n            map.remove();\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", {\n        className: \"w-full h-full relative\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n                id: \"map\",\n                className: \"w-full h-full rounded-lg overflow-hidden shadow-lg\"\n            }),\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n                className: \"absolute top-4 right-4 z-[1000]\",\n                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_MapLayers__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {})\n            })\n        ]\n    });\n}\n_s(LeafletMap, \"vWzsBvb7Xyp21ifmTUtqwqJ9O2s=\");\n_c1 = LeafletMap;\n_s1(LeafletMap, \"vWzsBvb7Xyp21ifmTUtqwqJ9O2s=\");\n_c = LeafletMap;\nvar _c;\n$RefreshReg$(_c, \"LeafletMap\");\nvar _c1;\n$RefreshReg$(_c1, \"LeafletMap\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL0xlYWZsZXRNYXAudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFhLElBQUFBLE1BQUFDO0FBRTRCO0FBQ047QUFBQztBQVFyQixTQUFTUTs7SUFBMEJUO0lBQ2hELE1BQU1VLFNBQVNQLDZDQUFNQSxDQUFNO0lBQzNCLE1BQU1RLFlBQVlSLDZDQUFNQSxDQUtyQjtRQUFFUyxVQUFVO1FBQU1DLGtCQUFrQjtRQUFNQyxjQUFjO1FBQU1DLGNBQWM7SUFBSztJQUVwRmIsZ0RBQVNBLENBQUM7WUEySlI7UUFDQWMsMEJBU0FBLDJCQVNBQSwyQkFTQUEsMkJBU0FBO1FBL0xBO1FBQ0EsSUFBSSxVQUFpQyxDQUFDQyxPQUFPQyxDQUFDLEVBQUU7WUFDOUNDLFFBQVFDLEtBQUssQ0FBQztZQUNkO1FBQ0Y7UUFFQTtRQUNBLE1BQU1DLE1BQU1KLE9BQU9DLENBQUMsQ0FBQ0csR0FBRyxDQUFDLE9BQU9DLE9BQU8sQ0FBQztZQUFDO1lBQU0sQ0FBQztTQUFLLEVBQUU7UUFDdkRaLE9BQU9hLE9BQU8sR0FBR0Y7UUFFakI7UUFDQUosT0FBT0MsQ0FBQyxDQUFDTSxTQUFTLENBQUMsc0RBQXNEO1lBQ3ZFQyxhQUFhO1FBQ2YsR0FBR0MsS0FBSyxDQUFDTDtRQUVUO1FBQ0EsTUFBTU0sU0FBUztZQUNiZixVQUFVSyxPQUFPQyxDQUFDLENBQUNVLFVBQVUsR0FBR0YsS0FBSyxDQUFDTDtZQUN0Q1Isa0JBQWtCSSxPQUFPQyxDQUFDLENBQUNVLFVBQVU7WUFDckNkLGNBQWNHLE9BQU9DLENBQUMsQ0FBQ1UsVUFBVTtZQUNqQ2IsY0FBY0UsT0FBT0MsQ0FBQyxDQUFDVSxVQUFVO1FBQ25DO1FBQ0FqQixVQUFVWSxPQUFPLEdBQUdJO1FBRXBCO1FBQ0EsTUFBTUUsUUFBUTtZQUNaQyxhQUFhYixPQUFPQyxDQUFDLENBQUNhLElBQUksQ0FBQztnQkFDekJDLFNBQVM7Z0JBQ1RDLFVBQVU7b0JBQUM7b0JBQUk7aUJB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QkFBeEJ6QyxnREFBQUEsMEJBQXNDa0UsZ0JBQWdCLENBQUMsVUFBVTtZQUMvRDNCO1FBQ0Y7UUFFQTtRQUNBbEI7UUFFQTtRQUNBLE9BQU87WUFDTGhCLElBQUltRSxNQUFNO1FBQ1o7SUFDRixHQUFHLEVBQUU7SUFFTCxxQkFDRWhGLHVEQUFBQSxDQUFBO1FBQUtzRSxXQUFVO1FBQXdCVyxVQUFBO1lBQUEsY0FDckNuRixzREFBQUEsQ0FBQTtnQkFBS29GLElBQUc7Z0JBQU1aLFdBQVU7WUFBb0Q7WUFBRyxjQUMvRXhFLHNEQUFBQSxDQUFBO2dCQUFLd0UsV0FBVTtnQkFBaUNXLFVBQUEsY0FDOUNuRixzREFBQUEsQ0FBQ0Ysa0RBQVNBLEVBQUE7WUFBRztTQUNUO0lBQUE7QUFHWjtHQTlOd0JLO01BQUFBO0FBOE52QlQsSUE5TnVCUyxZQUFVO0FBQUFrRixLQUFWbEY7QUFBVSxJQUFBa0Y7QUFBQUMsYUFBQUQsSUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY29tcG9uZW50cy9MZWFmbGV0TWFwLnRzeD81ZmU5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgTWFwTGF5ZXJzIGZyb20gJy4vTWFwTGF5ZXJzJztcblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICBMOiBhbnk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTGVhZmxldE1hcCgpOiBKU1guRWxlbWVudCB7XG4gIGNvbnN0IG1hcFJlZiA9IHVzZVJlZjxhbnk+KG51bGwpO1xuICBjb25zdCBsYXllcnNSZWYgPSB1c2VSZWY8e1xuICAgIGZpcmVSaXNrOiBhbnk7XG4gICAgZXZhY3VhdGlvblJvdXRlczogYW55O1xuICAgIGZpcmVTdGF0aW9uczogYW55O1xuICAgIHdhdGVyU291cmNlczogYW55O1xuICB9Pih7IGZpcmVSaXNrOiBudWxsLCBldmFjdWF0aW9uUm91dGVzOiBudWxsLCBmaXJlU3RhdGlvbnM6IG51bGwsIHdhdGVyU291cmNlczogbnVsbCB9KTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFdhaXQgZm9yIExlYWZsZXQgdG8gYmUgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cuTCkge1xuICAgICAgY29uc29sZS5lcnJvcignTGVhZmxldCBub3QgbG9hZGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBtYXBcbiAgICBjb25zdCBtYXAgPSB3aW5kb3cuTC5tYXAoJ21hcCcpLnNldFZpZXcoWzM5LjgsIC03NC41XSwgOSk7XG4gICAgbWFwUmVmLmN1cnJlbnQgPSBtYXA7XG5cbiAgICAvLyBBZGQgT3BlblN0cmVldE1hcCB0aWxlc1xuICAgIHdpbmRvdy5MLnRpbGVMYXllcignaHR0cHM6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmcnLCB7XG4gICAgICBhdHRyaWJ1dGlvbjogJ8KpIE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzJ1xuICAgIH0pLmFkZFRvKG1hcCk7XG5cbiAgICAvLyBJbml0aWFsaXplIGxheWVyIGdyb3Vwc1xuICAgIGNvbnN0IGxheWVycyA9IHtcbiAgICAgIGZpcmVSaXNrOiB3aW5kb3cuTC5sYXllckdyb3VwKCkuYWRkVG8obWFwKSxcbiAgICAgIGV2YWN1YXRpb25Sb3V0ZXM6IHdpbmRvdy5MLmxheWVyR3JvdXAoKSxcbiAgICAgIGZpcmVTdGF0aW9uczogd2luZG93LkwubGF5ZXJHcm91cCgpLFxuICAgICAgd2F0ZXJTb3VyY2VzOiB3aW5kb3cuTC5sYXllckdyb3VwKClcbiAgICB9O1xuICAgIGxheWVyc1JlZi5jdXJyZW50ID0gbGF5ZXJzO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBpY29uc1xuICAgIGNvbnN0IGljb25zID0ge1xuICAgICAgZmlyZVN0YXRpb246IHdpbmRvdy5MLmljb24oe1xuICAgICAgICBpY29uVXJsOiAnL3N0YXRpYy9pY29ucy9maXJlLXN0YXRpb24ucG5nJyxcbiAgICAgICAgaWNvblNpemU6IFszMiwgMzJdLFxuICAgICAgICBpY29uQW5jaG9yOiBbMTYsIDMyXSxcbiAgICAgICAgcG9wdXBBbmNob3I6IFswLCAtMzJdXG4gICAgICB9KSxcbiAgICAgIHdhdGVyU291cmNlOiB3aW5kb3cuTC5pY29uKHtcbiAgICAgICAgaWNvblVybDogJy9zdGF0aWMvaWNvbnMvd2F0ZXItc291cmNlLnBuZycsXG4gICAgICAgIGljb25TaXplOiBbMzIsIDMyXSxcbiAgICAgICAgaWNvbkFuY2hvcjogWzE2LCAzMl0sXG4gICAgICAgIHBvcHVwQW5jaG9yOiBbMCwgLTMyXVxuICAgICAgfSlcbiAgICB9O1xuXG4gICAgLy8gTG9hZCBpbml0aWFsIG1hcCBkYXRhXG4gICAgY29uc3QgbG9hZE1hcERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL21hcC1kYXRhJyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgLy8gQWRkIGZpcmUgc3RhdGlvbnNcbiAgICAgICAgZGF0YS5maXJlU3RhdGlvbnMuZm9yRWFjaCgoc3RhdGlvbjogYW55KSA9PiB7XG4gICAgICAgICAgd2luZG93LkwubWFya2VyKHN0YXRpb24uY29vcmRzLCB7IGljb246IGljb25zLmZpcmVTdGF0aW9uIH0pXG4gICAgICAgICAgICAuYmluZFBvcHVwKGA8Yj4ke3N0YXRpb24ubmFtZX08L2I+YClcbiAgICAgICAgICAgIC5hZGRUbyhsYXllcnMuZmlyZVN0YXRpb25zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkIHdhdGVyIHNvdXJjZXNcbiAgICAgICAgZGF0YS53YXRlclNvdXJjZXMuZm9yRWFjaCgoc291cmNlOiBhbnkpID0+IHtcbiAgICAgICAgICB3aW5kb3cuTC5tYXJrZXIoc291cmNlLmNvb3JkcywgeyBpY29uOiBpY29ucy53YXRlclNvdXJjZSB9KVxuICAgICAgICAgICAgLmJpbmRQb3B1cChgPGI+JHtzb3VyY2UubmFtZX08L2I+YClcbiAgICAgICAgICAgIC5hZGRUbyhsYXllcnMud2F0ZXJTb3VyY2VzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkIGV2YWN1YXRpb24gcm91dGVzXG4gICAgICAgIGRhdGEuZXZhY3VhdGlvblJvdXRlcy5mb3JFYWNoKChyb3V0ZTogYW55KSA9PiB7XG4gICAgICAgICAgd2luZG93LkwucG9seWxpbmUocm91dGUucGF0aCwge1xuICAgICAgICAgICAgY29sb3I6ICdibHVlJyxcbiAgICAgICAgICAgIHdlaWdodDogMyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuN1xuICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYmluZFBvcHVwKGA8Yj4ke3JvdXRlLm5hbWV9PC9iPmApXG4gICAgICAgICAgICAuYWRkVG8obGF5ZXJzLmV2YWN1YXRpb25Sb3V0ZXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJbml0aWFsIHJpc2sgYXJlYXMgdXBkYXRlXG4gICAgICAgIHVwZGF0ZVJpc2tBcmVhcygpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBtYXAgZGF0YTonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcblxuXG5cbiAgICAvLyBVcGRhdGUgcmlzayBhcmVhc1xuICAgIGNvbnN0IHVwZGF0ZVJpc2tBcmVhcyA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRpbWVSYW5nZSA9IChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGltZVJhbmdlJykgYXMgSFRNTFNlbGVjdEVsZW1lbnQpPy52YWx1ZSB8fCAnMjRoJztcbiAgICAgICAgbGF5ZXJzLmZpcmVSaXNrLmNsZWFyTGF5ZXJzKCk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9maXJlLXJpc2s/dGltZVJhbmdlPSR7dGltZVJhbmdlfWApO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgIC8vIEFkanVzdCByaXNrIGxldmVscyBiYXNlZCBvbiB3ZWF0aGVyXG4gICAgICAgIC8vIEdldCBjdXJyZW50IHdlYXRoZXIgZGF0YSBmaXJzdFxuICAgICAgICBjb25zdCB3ZWF0aGVyUmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jdXJyZW50LXdlYXRoZXInKTtcbiAgICAgICAgY29uc3QgY3VycmVudFdlYXRoZXIgPSBhd2FpdCB3ZWF0aGVyUmVzcG9uc2UuanNvbigpO1xuICAgICAgICBcbiAgICAgICAgZGF0YS5yaXNrQXJlYXMuZm9yRWFjaCgoYXJlYTogYW55KSA9PiB7XG4gICAgICAgICAgLy8gVXNlIGN1cnJlbnQgd2VhdGhlciBkYXRhIHRvIHVwZGF0ZSByaXNrIGxldmVsc1xuICAgICAgICAgIGNvbnN0IHdpbmRTcGVlZCA9IGN1cnJlbnRXZWF0aGVyLndpbmRTcGVlZDtcbiAgICAgICAgICBjb25zdCBodW1pZGl0eSA9IGN1cnJlbnRXZWF0aGVyLmh1bWlkaXR5O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBhcmVhJ3Mgd2VhdGhlciBmYWN0b3JzXG4gICAgICAgICAgYXJlYS5mYWN0b3JzID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAnVGVtcGVyYXR1cmUnLCB2YWx1ZTogYCR7Y3VycmVudFdlYXRoZXIudGVtcGVyYXR1cmV9wrBGYCB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnV2luZCBTcGVlZCcsIHZhbHVlOiBgJHt3aW5kU3BlZWR9IG1waCAke2N1cnJlbnRXZWF0aGVyLndpbmREaXJlY3Rpb259YCB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnSHVtaWRpdHknLCB2YWx1ZTogYCR7aHVtaWRpdHl9JWAgfVxuICAgICAgICAgIF07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWRqdXN0IHJpc2sgbGV2ZWwgYmFzZWQgb24gY3VycmVudCBjb25kaXRpb25zXG4gICAgICAgICAgaWYgKGh1bWlkaXR5IDwgMzAgJiYgd2luZFNwZWVkID4gMTUpIHtcbiAgICAgICAgICAgIGFyZWEucmlza0xldmVsID0gJ2V4dHJlbWUnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaHVtaWRpdHkgPCA0MCAmJiB3aW5kU3BlZWQgPiAxMCkge1xuICAgICAgICAgICAgYXJlYS5yaXNrTGV2ZWwgPSAnaGlnaCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChodW1pZGl0eSA+IDYwICYmIGN1cnJlbnRXZWF0aGVyLnRlbXBlcmF0dXJlIDwgNTApIHtcbiAgICAgICAgICAgIGFyZWEucmlza0xldmVsID0gJ2xvdyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Umlza0NvbG9yKGFyZWEucmlza0xldmVsKTtcbiAgICAgICAgICBjb25zdCByYWRpdXMgPSBhcmVhLnNldmVyaXR5ICogMTAwMDsgLy8gQ29udmVydCB0byBtZXRlcnNcblxuICAgICAgICAgIHdpbmRvdy5MLmNpcmNsZShhcmVhLmNvb3Jkcywge1xuICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgZmlsbENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjQsXG4gICAgICAgICAgICByYWRpdXM6IHJhZGl1c1xuICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYmluZFBvcHVwKGBcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInAtMlwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb250LWJvbGQgdGV4dC1sZyBtYi0yIGNhcGl0YWxpemVcIj5SaXNrIExldmVsOiAke2FyZWEucmlza0xldmVsfTwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb250LWJvbGQgbXQtMlwiPkN1cnJlbnQgQ29uZGl0aW9uczo8L2Rpdj5cbiAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJtdC0xXCI+XG4gICAgICAgICAgICAgICAgICAke2FyZWEuZmFjdG9ycy5tYXAoKGY6IGFueSkgPT4gYDxsaT7igKIgJHtmLm5hbWV9OiAke2YudmFsdWV9PC9saT5gKS5qb2luKCcnKX1cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIGAsIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnY3VzdG9tLXBvcHVwJyxcbiAgICAgICAgICAgICAgY2xvc2VCdXR0b246IHRydWUsXG4gICAgICAgICAgICAgIGF1dG9QYW46IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYWRkVG8obGF5ZXJzLmZpcmVSaXNrKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyByaXNrIGFyZWFzOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gR2V0IGNvbG9yIGJhc2VkIG9uIHJpc2sgbGV2ZWxcbiAgICBjb25zdCBnZXRSaXNrQ29sb3IgPSAocmlza0xldmVsOiBzdHJpbmcpID0+IHtcbiAgICAgIHN3aXRjaCAocmlza0xldmVsLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnZXh0cmVtZSc6IHJldHVybiAnI2ZmMDAwMCc7XG4gICAgICAgIGNhc2UgJ2hpZ2gnOiByZXR1cm4gJyNmZjY2MDAnO1xuICAgICAgICBjYXNlICdtb2RlcmF0ZSc6IHJldHVybiAnI2ZmY2MwMCc7XG4gICAgICAgIGNhc2UgJ2xvdyc6IHJldHVybiAnIzAwY2MwMCc7XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiAnIzAwZmYwMCc7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlyZVJpc2tMYXllcicpPy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgIGlmICh0YXJnZXQuY2hlY2tlZCkge1xuICAgICAgICBtYXAuYWRkTGF5ZXIobGF5ZXJzLmZpcmVSaXNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcC5yZW1vdmVMYXllcihsYXllcnMuZmlyZVJpc2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V2YWN1YXRpb25Sb3V0ZXMnKT8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICBpZiAodGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgICAgbWFwLmFkZExheWVyKGxheWVycy5ldmFjdWF0aW9uUm91dGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcC5yZW1vdmVMYXllcihsYXllcnMuZXZhY3VhdGlvblJvdXRlcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlyZVN0YXRpb25zJyk/LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgaWYgKHRhcmdldC5jaGVja2VkKSB7XG4gICAgICAgIG1hcC5hZGRMYXllcihsYXllcnMuZmlyZVN0YXRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcC5yZW1vdmVMYXllcihsYXllcnMuZmlyZVN0YXRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3YXRlclNvdXJjZXMnKT8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICBpZiAodGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgICAgbWFwLmFkZExheWVyKGxheWVycy53YXRlclNvdXJjZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwLnJlbW92ZUxheWVyKGxheWVycy53YXRlclNvdXJjZXMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RpbWVSYW5nZScpPy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICB1cGRhdGVSaXNrQXJlYXMoKTtcbiAgICB9KTtcblxuICAgIC8vIExvYWQgaW5pdGlhbCBkYXRhXG4gICAgbG9hZE1hcERhdGEoKTtcblxuICAgIC8vIENsZWFudXBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbWFwLnJlbW92ZSgpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCByZWxhdGl2ZVwiPlxuICAgICAgPGRpdiBpZD1cIm1hcFwiIGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgcm91bmRlZC1sZyBvdmVyZmxvdy1oaWRkZW4gc2hhZG93LWxnXCIgLz5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgdG9wLTQgcmlnaHQtNCB6LVsxMDAwXVwiPlxuICAgICAgICA8TWFwTGF5ZXJzIC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJfcyIsIiRSZWZyZXNoU2lnJCIsInVzZUVmZmVjdCIsInVzZVJlZiIsIk1hcExheWVycyIsImpzeCIsIl9qc3giLCJqc3hzIiwiX2pzeHMiLCJMZWFmbGV0TWFwIiwibWFwUmVmIiwibGF5ZXJzUmVmIiwiZmlyZVJpc2siLCJldmFjdWF0aW9uUm91dGVzIiwiZmlyZVN0YXRpb25zIiwid2F0ZXJTb3VyY2VzIiwiZG9jdW1lbnQiLCJ3aW5kb3ciLCJMIiwiY29uc29sZSIsImVycm9yIiwibWFwIiwic2V0VmlldyIsImN1cnJlbnQiLCJ0aWxlTGF5ZXIiLCJhdHRyaWJ1dGlvbiIsImFkZFRvIiwibGF5ZXJzIiwibGF5ZXJHcm91cCIsImljb25zIiwiZmlyZVN0YXRpb24iLCJpY29uIiwiaWNvblVybCIsImljb25TaXplIiwiaWNvbkFuY2hvciIsInBvcHVwQW5jaG9yIiwid2F0ZXJTb3VyY2UiLCJsb2FkTWFwRGF0YSIsInJlc3BvbnNlIiwiZmV0Y2giLCJkYXRhIiwianNvbiIsImZvckVhY2giLCJzdGF0aW9uIiwibWFya2VyIiwiY29vcmRzIiwiYmluZFBvcHVwIiwibmFtZSIsInNvdXJjZSIsInJvdXRlIiwicG9seWxpbmUiLCJwYXRoIiwiY29sb3IiLCJ3ZWlnaHQiLCJvcGFjaXR5IiwidXBkYXRlUmlza0FyZWFzIiwidGltZVJhbmdlIiwiZ2V0RWxlbWVudEJ5SWQiLCJ2YWx1ZSIsImNsZWFyTGF5ZXJzIiwid2VhdGhlclJlc3BvbnNlIiwiY3VycmVudFdlYXRoZXIiLCJyaXNrQXJlYXMiLCJhcmVhIiwid2luZFNwZWVkIiwiaHVtaWRpdHkiLCJmYWN0b3JzIiwidGVtcGVyYXR1cmUiLCJ3aW5kRGlyZWN0aW9uIiwicmlza0xldmVsIiwiZ2V0Umlza0NvbG9yIiwicmFkaXVzIiwic2V2ZXJpdHkiLCJjaXJjbGUiLCJmaWxsQ29sb3IiLCJmaWxsT3BhY2l0eSIsImYiLCJqb2luIiwiY2xhc3NOYW1lIiwiY2xvc2VCdXR0b24iLCJhdXRvUGFuIiwidG9Mb3dlckNhc2UiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsInRhcmdldCIsImNoZWNrZWQiLCJhZGRMYXllciIsInJlbW92ZUxheWVyIiwicmVtb3ZlIiwiY2hpbGRyZW4iLCJpZCIsIl9jIiwiJFJlZnJlc2hSZWckIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/LeafletMap.tsx\n"));

/***/ })

}]);