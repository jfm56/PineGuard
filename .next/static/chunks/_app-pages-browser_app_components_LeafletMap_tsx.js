"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_app_components_LeafletMap_tsx"],{

/***/ "(app-pages-browser)/./app/components/LeafletMap.tsx":
/*!***************************************!*\
  !*** ./app/components/LeafletMap.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ LeafletMap; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _MapLayers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MapLayers */ \"(app-pages-browser)/./app/components/MapLayers.tsx\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ var _s = $RefreshSig$();\nvar _s1 = $RefreshSig$();\n\n\n\nfunction LeafletMap() {\n    _s();\n    _s1();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const layersRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var // Add event listeners\n        _document_getElementById, _document_getElementById1, _document_getElementById2, _document_getElementById3, _document_getElementById4;\n        // Wait for Leaflet to be available\n        if ( false || !window.L) {\n            console.error(\"Leaflet not loaded\");\n            return;\n        }\n        // Initialize map\n        const map = window.L.map(\"map\").setView([\n            39.8,\n            -74.5\n        ], 9);\n        mapRef.current = map;\n        // Add OpenStreetMap tiles\n        window.L.tileLayer(\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\", {\n            attribution: \"\\xa9 OpenStreetMap contributors\"\n        }).addTo(map);\n        // Initialize layer groups\n        const layers = {\n            fireRisk: window.L.layerGroup().addTo(map),\n            evacuationRoutes: window.L.layerGroup(),\n            fireStations: window.L.layerGroup(),\n            waterSources: window.L.layerGroup()\n        };\n        layersRef.current = layers;\n        // Initialize icons\n        const icons = {\n            fireStation: window.L.icon({\n                iconUrl: \"/static/icons/fire-station.png\",\n                iconSize: [\n                    32,\n                    32\n                ],\n                iconAnchor: [\n                    16,\n                    32\n                ],\n                popupAnchor: [\n                    0,\n                    -32\n                ]\n            }),\n            waterSource: window.L.icon({\n                iconUrl: \"/static/icons/water-source.png\",\n                iconSize: [\n                    32,\n                    32\n                ],\n                iconAnchor: [\n                    16,\n                    32\n                ],\n                popupAnchor: [\n                    0,\n                    -32\n                ]\n            })\n        };\n        // Load initial map data\n        const loadMapData = async ()=>{\n            try {\n                const response = await fetch(\"/api/map-data\");\n                const data = await response.json();\n                if (typeof data === \"object\" && data !== null && Array.isArray(data.fireStations) && Array.isArray(data.waterSources) && Array.isArray(data.evacuationRoutes)) {\n                    const mapData = data;\n                    // Add fire stations\n                    mapData.fireStations.forEach((station)=>{\n                        if (Array.isArray(station.coords) && station.coords.length === 2 && typeof station.name === \"string\") {\n                            window.L.marker(station.coords, {\n                                icon: icons.fireStation\n                            }).bindPopup(\"<b>\".concat(station.name, \"</b>\")).addTo(layers.fireStations);\n                        }\n                    });\n                    // Add water sources\n                    mapData.waterSources.forEach((source)=>{\n                        if (Array.isArray(source.coords) && source.coords.length === 2 && typeof source.name === \"string\") {\n                            window.L.marker(source.coords, {\n                                icon: icons.waterSource\n                            }).bindPopup(\"<b>\".concat(source.name, \"</b>\")).addTo(layers.waterSources);\n                        }\n                    });\n                    // Add evacuation routes\n                    mapData.evacuationRoutes.forEach((route)=>{\n                        if (Array.isArray(route.path) && typeof route.name === \"string\") {\n                            window.L.polyline(route.path, {\n                                color: \"blue\",\n                                weight: 3,\n                                opacity: 0.7\n                            }).bindPopup(\"<b>\".concat(route.name, \"</b>\")).addTo(layers.evacuationRoutes);\n                        }\n                    });\n                    // Initial risk areas update\n                    void updateRiskAreas();\n                } else {\n                    throw new Error(\"Invalid map data format\");\n                }\n            } catch (error) {\n                console.error(\"Error loading map data:\", error);\n            }\n        };\n        // Update risk areas\n        const updateRiskAreas = async ()=>{\n            try {\n                var _document_getElementById;\n                const timeRange = ((_document_getElementById = document.getElementById(\"timeRange\")) === null || _document_getElementById === void 0 ? void 0 : _document_getElementById.value) || \"24h\";\n                layers.fireRisk.clearLayers();\n                const response = await fetch(\"/api/fire-risk?timeRange=\".concat(timeRange));\n                const data = await response.json();\n                // Get current weather data first\n                const weatherResponse = await fetch(\"/api/current-weather\");\n                const currentWeatherRaw = await weatherResponse.json();\n                let currentWeather = {\n                    windSpeed: 0,\n                    windDirection: \"\",\n                    humidity: 0,\n                    temperature: 0\n                };\n                if (typeof currentWeatherRaw === \"object\" && currentWeatherRaw !== null && typeof currentWeatherRaw.windSpeed === \"number\" && typeof currentWeatherRaw.windDirection === \"string\" && typeof currentWeatherRaw.humidity === \"number\" && typeof currentWeatherRaw.temperature === \"number\") {\n                    currentWeather = currentWeatherRaw;\n                }\n                if (typeof data === \"object\" && data !== null && Array.isArray(data.riskAreas)) {\n                    const fireRiskData = data;\n                    fireRiskData.riskAreas.forEach((area)=>{\n                        if (Array.isArray(area.coords) && area.coords.length === 2 && typeof area.severity === \"number\" && typeof area.riskLevel === \"string\") {\n                            // Use current weather data to update risk levels\n                            const windSpeed = currentWeather.windSpeed;\n                            const humidity = currentWeather.humidity;\n                            // Update area's weather factors\n                            area.factors = [\n                                {\n                                    name: \"Temperature\",\n                                    value: \"\".concat(currentWeather.temperature, \"\\xb0F\")\n                                },\n                                {\n                                    name: \"Wind Speed\",\n                                    value: \"\".concat(windSpeed, \" mph \").concat(currentWeather.windDirection)\n                                },\n                                {\n                                    name: \"Humidity\",\n                                    value: \"\".concat(humidity, \"%\")\n                                }\n                            ];\n                            // Adjust risk level based on current conditions\n                            if (humidity < 30 && windSpeed > 15) {\n                                area.riskLevel = \"extreme\";\n                            } else if (humidity < 40 && windSpeed > 10) {\n                                area.riskLevel = \"high\";\n                            } else if (humidity > 60 && currentWeather.temperature < 50) {\n                                area.riskLevel = \"low\";\n                            }\n                            const color = getRiskColor(area.riskLevel);\n                            const radius = area.severity * 1000; // Convert to meters\n                            window.L.circle(area.coords, {\n                                color: color,\n                                fillColor: color,\n                                fillOpacity: 0.4,\n                                radius: radius\n                            }).bindPopup('\\n              <div class=\"p-2\">\\n                <div class=\"font-bold text-lg mb-2 capitalize\">Risk Level: '.concat(String(area.riskLevel), '</div>\\n                <div class=\"font-bold mt-2\">Current Conditions:</div>\\n                <ul class=\"mt-1\">\\n                  ').concat((Array.isArray(area.factors) ? area.factors : []).map((f)=>\"<li>• \".concat(f.name, \": \").concat(f.value, \"</li>\")).join(\"\"), \"\\n                </ul>\\n              </div>\\n            \"), {\n                                className: \"custom-popup\",\n                                closeButton: true,\n                                autoPan: true\n                            }).addTo(layers.fireRisk);\n                        }\n                    });\n                } else {\n                    throw new Error(\"Invalid fire risk data format\");\n                }\n            } catch (error) {\n                console.error(\"Error updating risk areas:\", error);\n            }\n        };\n        // Get color based on risk level\n        const getRiskColor = (riskLevel)=>{\n            switch(riskLevel.toLowerCase()){\n                case \"extreme\":\n                    return \"#ff0000\";\n                case \"high\":\n                    return \"#ff6600\";\n                case \"moderate\":\n                    return \"#ffcc00\";\n                case \"low\":\n                    return \"#00cc00\";\n                default:\n                    return \"#00ff00\";\n            }\n        };\n        (_document_getElementById = document.getElementById(\"fireRiskLayer\")) === null || _document_getElementById === void 0 ? void 0 : _document_getElementById.addEventListener(\"change\", (e)=>{\n            const target = e.target;\n            if (target.checked) {\n                map.addLayer(layers.fireRisk);\n            } else {\n                map.removeLayer(layers.fireRisk);\n            }\n        });\n        (_document_getElementById1 = document.getElementById(\"evacuationRoutes\")) === null || _document_getElementById1 === void 0 ? void 0 : _document_getElementById1.addEventListener(\"change\", (e)=>{\n            const target = e.target;\n            if (target.checked) {\n                map.addLayer(layers.evacuationRoutes);\n            } else {\n                map.removeLayer(layers.evacuationRoutes);\n            }\n        });\n        (_document_getElementById2 = document.getElementById(\"fireStations\")) === null || _document_getElementById2 === void 0 ? void 0 : _document_getElementById2.addEventListener(\"change\", (e)=>{\n            const target = e.target;\n            if (target.checked) {\n                map.addLayer(layers.fireStations);\n            } else {\n                map.removeLayer(layers.fireStations);\n            }\n        });\n        (_document_getElementById3 = document.getElementById(\"waterSources\")) === null || _document_getElementById3 === void 0 ? void 0 : _document_getElementById3.addEventListener(\"change\", (e)=>{\n            const target = e.target;\n            if (target.checked) {\n                map.addLayer(layers.waterSources);\n            } else {\n                map.removeLayer(layers.waterSources);\n            }\n        });\n        (_document_getElementById4 = document.getElementById(\"timeRange\")) === null || _document_getElementById4 === void 0 ? void 0 : _document_getElementById4.addEventListener(\"change\", ()=>{\n            void updateRiskAreas();\n        });\n        // Load initial data\n        void loadMapData();\n        // Cleanup\n        return ()=>{\n            map.remove();\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", {\n        className: \"w-full h-full relative\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n                id: \"map\",\n                className: \"w-full h-full rounded-lg overflow-hidden shadow-lg\"\n            }),\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n                className: \"absolute top-4 right-4 z-[1000]\",\n                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_MapLayers__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {})\n            })\n        ]\n    });\n}\n_s(LeafletMap, \"vWzsBvb7Xyp21ifmTUtqwqJ9O2s=\");\n_c1 = LeafletMap;\n_s1(LeafletMap, \"vWzsBvb7Xyp21ifmTUtqwqJ9O2s=\");\n_c = LeafletMap;\nvar _c;\n$RefreshReg$(_c, \"LeafletMap\");\nvar _c1;\n$RefreshReg$(_c1, \"LeafletMap\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL0xlYWZsZXRNYXAudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFhLElBQUFBLE1BQUFDO0FBRTRCO0FBQ047QUFBQztBQWVyQixTQUFTUTs7SUFBMEJUO0lBQ2hELE1BQU1VLFNBQVNQLDZDQUFNQSxDQUFlO0lBQ3BDLE1BQU1RLFlBQVlSLDZDQUFNQSxDQUF1QjtJQUUvQ0QsZ0RBQVNBLENBQUM7WUF5TlI7UUFDQVUsMEJBU0FBLDJCQVNBQSwyQkFTQUEsMkJBU0FBO1FBN1BBO1FBQ0EsSUFBSSxVQUFpQyxDQUFDQyxPQUFPQyxDQUFDLEVBQUU7WUFDOUNDLFFBQVFDLEtBQUssQ0FBQztZQUNkO1FBQ0Y7UUFFQTtRQUNBLE1BQU1DLE1BQU1KLE9BQU9DLENBQUMsQ0FBQ0csR0FBRyxDQUFDLE9BQU9DLE9BQU8sQ0FBQztZQUFDO1lBQU0sQ0FBQztTQUFLLEVBQUU7UUFDdkRSLE9BQU9TLE9BQU8sR0FBR0Y7UUFFakI7UUFDQUosT0FBT0MsQ0FBQyxDQUFDTSxTQUFTLENBQUMsc0RBQXNEO1lBQ3ZFQyxhQUFhO1FBQ2YsR0FBR0MsS0FBSyxDQUFDTDtRQUVUO1FBQ0EsTUFBTU0sU0FBUztZQUNiQyxVQUFVWCxPQUFPQyxDQUFDLENBQUNXLFVBQVUsR0FBR0gsS0FBSyxDQUFDTDtZQUN0Q1Msa0JBQWtCYixPQUFPQyxDQUFDLENBQUNXLFVBQVU7WUFDckNFLGNBQWNkLE9BQU9DLENBQUMsQ0FBQ1csVUFBVTtZQUNqQ0csY0FBY2YsT0FBT0MsQ0FBQyxDQUFDVyxVQUFVO1FBQ25DO1FBQ0FkLFVBQVVRLE9BQU8sR0FBR0k7UUFFcEI7UUFDQSxNQUFNTSxRQUFRO1lBQ1pDLGFBQWFqQixPQUFPQyxDQUFDLENBQUNpQixJQUFJLENBQUM7Z0JBQ3pCQyxTQUFTO2dCQUNUQyxVQUFVO29CQUFDO29CQUFJO2lCQUFHO2dCQUNsQkMsWUFBWTtvQkFBQztvQkFBSTtpQkFBRztnQkFDcEJDLGFBQWE7b0JB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QU1DLFNBQVNELEVBQUVDLE1BQTBCO1lBQzNDLElBQUlBLE9BQU9DLE9BQU8sRUFBRTtnQkFDbEI1RSxJQUFJNkUsUUFBUSxDQUFDdkUsT0FBT0ssWUFBWTtZQUNsQyxPQUFPO2dCQUNMWCxJQUFJOEUsV0FBVyxDQUFDeEUsT0FBT0ssWUFBWTtZQUNyQztRQUNGO1NBRUFoQiw0QkFBQUEsU0FBU2tELGNBQWMsQ0FBQywwQkFBeEJsRCxnREFBQUEsMEJBQXNDOEUsZ0JBQWdCLENBQUMsVUFBVTtZQUMvRCxLQUFLL0I7UUFDUDtRQUVBO1FBQ0EsS0FBS3RCO1FBRUw7UUFDQSxPQUFPO1lBQ0xwQixJQUFJK0UsTUFBTTtRQUNaO0lBQ0YsR0FBRyxFQUFFO0lBRUwscUJBQ0V4Rix1REFBQUEsQ0FBQTtRQUFLOEUsV0FBVTtRQUF3QlcsVUFBQTtZQUFBLGNBQ3JDM0Ysc0RBQUFBLENBQUE7Z0JBQUs0RixJQUFHO2dCQUFNWixXQUFVO1lBQW9EO1lBQUcsY0FDL0VoRixzREFBQUEsQ0FBQTtnQkFBS2dGLFdBQVU7Z0JBQWlDVyxVQUFBLGNBQzlDM0Ysc0RBQUFBLENBQUNGLGtEQUFTQSxFQUFBO1lBQUc7U0FDVDtJQUFBO0FBR1o7R0F2UndCSztNQUFBQTtBQXVSdkJULElBdlJ1QlMsWUFBVTtBQUFBMEYsS0FBVjFGO0FBQVUsSUFBQTBGO0FBQUFDLGFBQUFELElBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2NvbXBvbmVudHMvTGVhZmxldE1hcC50c3g/NWZlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IE1hcExheWVycyBmcm9tICcuL01hcExheWVycyc7XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgTDogdHlwZW9mIGltcG9ydCgnbGVhZmxldCcpO1xuICB9XG59XG5cbnR5cGUgTGF5ZXJHcm91cE1hcCA9IHtcbiAgZmlyZVJpc2s6IEwuTGF5ZXJHcm91cDtcbiAgZXZhY3VhdGlvblJvdXRlczogTC5MYXllckdyb3VwO1xuICBmaXJlU3RhdGlvbnM6IEwuTGF5ZXJHcm91cDtcbiAgd2F0ZXJTb3VyY2VzOiBMLkxheWVyR3JvdXA7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMZWFmbGV0TWFwKCk6IEpTWC5FbGVtZW50IHtcbiAgY29uc3QgbWFwUmVmID0gdXNlUmVmPEwuTWFwIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGxheWVyc1JlZiA9IHVzZVJlZjxMYXllckdyb3VwTWFwIHwgbnVsbD4obnVsbCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBXYWl0IGZvciBMZWFmbGV0IHRvIGJlIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93LkwpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xlYWZsZXQgbm90IGxvYWRlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgbWFwXG4gICAgY29uc3QgbWFwID0gd2luZG93LkwubWFwKCdtYXAnKS5zZXRWaWV3KFszOS44LCAtNzQuNV0sIDkpO1xuICAgIG1hcFJlZi5jdXJyZW50ID0gbWFwO1xuXG4gICAgLy8gQWRkIE9wZW5TdHJlZXRNYXAgdGlsZXNcbiAgICB3aW5kb3cuTC50aWxlTGF5ZXIoJ2h0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJywge1xuICAgICAgYXR0cmlidXRpb246ICfCqSBPcGVuU3RyZWV0TWFwIGNvbnRyaWJ1dG9ycydcbiAgICB9KS5hZGRUbyhtYXApO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBsYXllciBncm91cHNcbiAgICBjb25zdCBsYXllcnMgPSB7XG4gICAgICBmaXJlUmlzazogd2luZG93LkwubGF5ZXJHcm91cCgpLmFkZFRvKG1hcCksXG4gICAgICBldmFjdWF0aW9uUm91dGVzOiB3aW5kb3cuTC5sYXllckdyb3VwKCksXG4gICAgICBmaXJlU3RhdGlvbnM6IHdpbmRvdy5MLmxheWVyR3JvdXAoKSxcbiAgICAgIHdhdGVyU291cmNlczogd2luZG93LkwubGF5ZXJHcm91cCgpXG4gICAgfTtcbiAgICBsYXllcnNSZWYuY3VycmVudCA9IGxheWVycztcblxuICAgIC8vIEluaXRpYWxpemUgaWNvbnNcbiAgICBjb25zdCBpY29ucyA9IHtcbiAgICAgIGZpcmVTdGF0aW9uOiB3aW5kb3cuTC5pY29uKHtcbiAgICAgICAgaWNvblVybDogJy9zdGF0aWMvaWNvbnMvZmlyZS1zdGF0aW9uLnBuZycsXG4gICAgICAgIGljb25TaXplOiBbMzIsIDMyXSxcbiAgICAgICAgaWNvbkFuY2hvcjogWzE2LCAzMl0sXG4gICAgICAgIHBvcHVwQW5jaG9yOiBbMCwgLTMyXVxuICAgICAgfSksXG4gICAgICB3YXRlclNvdXJjZTogd2luZG93LkwuaWNvbih7XG4gICAgICAgIGljb25Vcmw6ICcvc3RhdGljL2ljb25zL3dhdGVyLXNvdXJjZS5wbmcnLFxuICAgICAgICBpY29uU2l6ZTogWzMyLCAzMl0sXG4gICAgICAgIGljb25BbmNob3I6IFsxNiwgMzJdLFxuICAgICAgICBwb3B1cEFuY2hvcjogWzAsIC0zMl1cbiAgICAgIH0pXG4gICAgfTtcblxuICAgIC8vIExvYWQgaW5pdGlhbCBtYXAgZGF0YVxuICAgIGludGVyZmFjZSBGaXJlU3RhdGlvbiB7XG4gIGNvb3JkczogW251bWJlciwgbnVtYmVyXTtcbiAgbmFtZTogc3RyaW5nO1xufVxuaW50ZXJmYWNlIFdhdGVyU291cmNlIHtcbiAgY29vcmRzOiBbbnVtYmVyLCBudW1iZXJdO1xuICBuYW1lOiBzdHJpbmc7XG59XG5pbnRlcmZhY2UgRXZhY3VhdGlvblJvdXRlIHtcbiAgcGF0aDogW251bWJlciwgbnVtYmVyXVtdO1xuICBuYW1lOiBzdHJpbmc7XG59XG5pbnRlcmZhY2UgTWFwRGF0YSB7XG4gIGZpcmVTdGF0aW9uczogRmlyZVN0YXRpb25bXTtcbiAgd2F0ZXJTb3VyY2VzOiBXYXRlclNvdXJjZVtdO1xuICBldmFjdWF0aW9uUm91dGVzOiBFdmFjdWF0aW9uUm91dGVbXTtcbn1cblxuY29uc3QgbG9hZE1hcERhdGEgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9tYXAtZGF0YScpO1xuICAgIGNvbnN0IGRhdGE6IHVua25vd24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgIT09IG51bGwgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkoKGRhdGEgYXMgTWFwRGF0YSkuZmlyZVN0YXRpb25zKSAmJlxuICAgICAgQXJyYXkuaXNBcnJheSgoZGF0YSBhcyBNYXBEYXRhKS53YXRlclNvdXJjZXMpICYmXG4gICAgICBBcnJheS5pc0FycmF5KChkYXRhIGFzIE1hcERhdGEpLmV2YWN1YXRpb25Sb3V0ZXMpXG4gICAgKSB7XG4gICAgICBjb25zdCBtYXBEYXRhID0gZGF0YSBhcyBNYXBEYXRhO1xuICAgICAgLy8gQWRkIGZpcmUgc3RhdGlvbnNcbiAgICAgIG1hcERhdGEuZmlyZVN0YXRpb25zLmZvckVhY2goKHN0YXRpb24pID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGlvbi5jb29yZHMpICYmIHN0YXRpb24uY29vcmRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2Ygc3RhdGlvbi5uYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHdpbmRvdy5MLm1hcmtlcihzdGF0aW9uLmNvb3JkcyBhcyBbbnVtYmVyLCBudW1iZXJdLCB7IGljb246IGljb25zLmZpcmVTdGF0aW9uIH0pXG4gICAgICAgICAgICAuYmluZFBvcHVwKGA8Yj4ke3N0YXRpb24ubmFtZX08L2I+YClcbiAgICAgICAgICAgIC5hZGRUbyhsYXllcnMuZmlyZVN0YXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBBZGQgd2F0ZXIgc291cmNlc1xuICAgICAgbWFwRGF0YS53YXRlclNvdXJjZXMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZS5jb29yZHMpICYmIHNvdXJjZS5jb29yZHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBzb3VyY2UubmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB3aW5kb3cuTC5tYXJrZXIoc291cmNlLmNvb3JkcyBhcyBbbnVtYmVyLCBudW1iZXJdLCB7IGljb246IGljb25zLndhdGVyU291cmNlIH0pXG4gICAgICAgICAgICAuYmluZFBvcHVwKGA8Yj4ke3NvdXJjZS5uYW1lfTwvYj5gKVxuICAgICAgICAgICAgLmFkZFRvKGxheWVycy53YXRlclNvdXJjZXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEFkZCBldmFjdWF0aW9uIHJvdXRlc1xuICAgICAgbWFwRGF0YS5ldmFjdWF0aW9uUm91dGVzLmZvckVhY2goKHJvdXRlKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvdXRlLnBhdGgpICYmIHR5cGVvZiByb3V0ZS5uYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHdpbmRvdy5MLnBvbHlsaW5lKHJvdXRlLnBhdGgsIHtcbiAgICAgICAgICAgIGNvbG9yOiAnYmx1ZScsXG4gICAgICAgICAgICB3ZWlnaHQ6IDMsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjdcbiAgICAgICAgICB9KVxuICAgICAgICAgICAgLmJpbmRQb3B1cChgPGI+JHtyb3V0ZS5uYW1lfTwvYj5gKVxuICAgICAgICAgICAgLmFkZFRvKGxheWVycy5ldmFjdWF0aW9uUm91dGVzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBJbml0aWFsIHJpc2sgYXJlYXMgdXBkYXRlXG4gICAgICB2b2lkIHVwZGF0ZVJpc2tBcmVhcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFwIGRhdGEgZm9ybWF0Jyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgbWFwIGRhdGE6JywgZXJyb3IpO1xuICB9XG59O1xuXG5cblxuICAgIC8vIFVwZGF0ZSByaXNrIGFyZWFzXG4gICAgaW50ZXJmYWNlIFJpc2tBcmVhIHtcbiAgY29vcmRzOiBbbnVtYmVyLCBudW1iZXJdO1xuICBzZXZlcml0eTogbnVtYmVyO1xuICByaXNrTGV2ZWw6IHN0cmluZztcbiAgZmFjdG9yczogeyBuYW1lOiBzdHJpbmc7IHZhbHVlOiBzdHJpbmcgfVtdO1xufVxuaW50ZXJmYWNlIEZpcmVSaXNrRGF0YSB7XG4gIHJpc2tBcmVhczogUmlza0FyZWFbXTtcbn1cbmludGVyZmFjZSBXZWF0aGVyRGF0YSB7XG4gIHdpbmRTcGVlZDogbnVtYmVyO1xuICB3aW5kRGlyZWN0aW9uOiBzdHJpbmc7XG4gIGh1bWlkaXR5OiBudW1iZXI7XG4gIHRlbXBlcmF0dXJlOiBudW1iZXI7XG59XG5cbmNvbnN0IHVwZGF0ZVJpc2tBcmVhcyA9IGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0aW1lUmFuZ2UgPSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RpbWVSYW5nZScpIGFzIEhUTUxTZWxlY3RFbGVtZW50KT8udmFsdWUgfHwgJzI0aCc7XG4gICAgbGF5ZXJzLmZpcmVSaXNrLmNsZWFyTGF5ZXJzKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9maXJlLXJpc2s/dGltZVJhbmdlPSR7dGltZVJhbmdlfWApO1xuICAgIGNvbnN0IGRhdGE6IHVua25vd24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgLy8gR2V0IGN1cnJlbnQgd2VhdGhlciBkYXRhIGZpcnN0XG4gICAgY29uc3Qgd2VhdGhlclJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY3VycmVudC13ZWF0aGVyJyk7XG4gICAgY29uc3QgY3VycmVudFdlYXRoZXJSYXc6IHVua25vd24gPSBhd2FpdCB3ZWF0aGVyUmVzcG9uc2UuanNvbigpO1xuICAgIGxldCBjdXJyZW50V2VhdGhlcjogV2VhdGhlckRhdGEgPSB7IHdpbmRTcGVlZDogMCwgd2luZERpcmVjdGlvbjogJycsIGh1bWlkaXR5OiAwLCB0ZW1wZXJhdHVyZTogMCB9O1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBjdXJyZW50V2VhdGhlclJhdyA9PT0gJ29iamVjdCcgJiYgY3VycmVudFdlYXRoZXJSYXcgIT09IG51bGwgJiZcbiAgICAgIHR5cGVvZiAoY3VycmVudFdlYXRoZXJSYXcgYXMgV2VhdGhlckRhdGEpLndpbmRTcGVlZCA9PT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiAoY3VycmVudFdlYXRoZXJSYXcgYXMgV2VhdGhlckRhdGEpLndpbmREaXJlY3Rpb24gPT09ICdzdHJpbmcnICYmXG4gICAgICB0eXBlb2YgKGN1cnJlbnRXZWF0aGVyUmF3IGFzIFdlYXRoZXJEYXRhKS5odW1pZGl0eSA9PT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiAoY3VycmVudFdlYXRoZXJSYXcgYXMgV2VhdGhlckRhdGEpLnRlbXBlcmF0dXJlID09PSAnbnVtYmVyJ1xuICAgICkge1xuICAgICAgY3VycmVudFdlYXRoZXIgPSBjdXJyZW50V2VhdGhlclJhdyBhcyBXZWF0aGVyRGF0YTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgIT09IG51bGwgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkoKGRhdGEgYXMgRmlyZVJpc2tEYXRhKS5yaXNrQXJlYXMpXG4gICAgKSB7XG4gICAgICBjb25zdCBmaXJlUmlza0RhdGEgPSBkYXRhIGFzIEZpcmVSaXNrRGF0YTtcbiAgICAgIGZpcmVSaXNrRGF0YS5yaXNrQXJlYXMuZm9yRWFjaCgoYXJlYTogUmlza0FyZWEpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIEFycmF5LmlzQXJyYXkoYXJlYS5jb29yZHMpICYmIGFyZWEuY29vcmRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgIHR5cGVvZiBhcmVhLnNldmVyaXR5ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXJlYS5yaXNrTGV2ZWwgPT09ICdzdHJpbmcnXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFVzZSBjdXJyZW50IHdlYXRoZXIgZGF0YSB0byB1cGRhdGUgcmlzayBsZXZlbHNcbiAgICAgICAgICBjb25zdCB3aW5kU3BlZWQgPSBjdXJyZW50V2VhdGhlci53aW5kU3BlZWQ7XG4gICAgICAgICAgY29uc3QgaHVtaWRpdHkgPSBjdXJyZW50V2VhdGhlci5odW1pZGl0eTtcbiAgICAgICAgICAvLyBVcGRhdGUgYXJlYSdzIHdlYXRoZXIgZmFjdG9yc1xuICAgICAgICAgIGFyZWEuZmFjdG9ycyA9IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ1RlbXBlcmF0dXJlJywgdmFsdWU6IGAke2N1cnJlbnRXZWF0aGVyLnRlbXBlcmF0dXJlfcKwRmAgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ1dpbmQgU3BlZWQnLCB2YWx1ZTogYCR7d2luZFNwZWVkfSBtcGggJHtjdXJyZW50V2VhdGhlci53aW5kRGlyZWN0aW9ufWAgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ0h1bWlkaXR5JywgdmFsdWU6IGAke2h1bWlkaXR5fSVgIH1cbiAgICAgICAgICBdO1xuICAgICAgICAgIC8vIEFkanVzdCByaXNrIGxldmVsIGJhc2VkIG9uIGN1cnJlbnQgY29uZGl0aW9uc1xuICAgICAgICAgIGlmIChodW1pZGl0eSA8IDMwICYmIHdpbmRTcGVlZCA+IDE1KSB7XG4gICAgICAgICAgICBhcmVhLnJpc2tMZXZlbCA9ICdleHRyZW1lJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGh1bWlkaXR5IDwgNDAgJiYgd2luZFNwZWVkID4gMTApIHtcbiAgICAgICAgICAgIGFyZWEucmlza0xldmVsID0gJ2hpZ2gnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaHVtaWRpdHkgPiA2MCAmJiBjdXJyZW50V2VhdGhlci50ZW1wZXJhdHVyZSA8IDUwKSB7XG4gICAgICAgICAgICBhcmVhLnJpc2tMZXZlbCA9ICdsb3cnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjb2xvciA9IGdldFJpc2tDb2xvcihhcmVhLnJpc2tMZXZlbCk7XG4gICAgICAgICAgY29uc3QgcmFkaXVzID0gYXJlYS5zZXZlcml0eSAqIDEwMDA7IC8vIENvbnZlcnQgdG8gbWV0ZXJzXG4gICAgICAgICAgd2luZG93LkwuY2lyY2xlKGFyZWEuY29vcmRzIGFzIFtudW1iZXIsIG51bWJlcl0sIHtcbiAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGZpbGxDb2xvcjogY29sb3IsXG4gICAgICAgICAgICBmaWxsT3BhY2l0eTogMC40LFxuICAgICAgICAgICAgcmFkaXVzOiByYWRpdXNcbiAgICAgICAgICB9KVxuICAgICAgICAgICAgLmJpbmRQb3B1cChgXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwLTJcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9udC1ib2xkIHRleHQtbGcgbWItMiBjYXBpdGFsaXplXCI+UmlzayBMZXZlbDogJHtTdHJpbmcoYXJlYS5yaXNrTGV2ZWwpfTwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb250LWJvbGQgbXQtMlwiPkN1cnJlbnQgQ29uZGl0aW9uczo8L2Rpdj5cbiAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJtdC0xXCI+XG4gICAgICAgICAgICAgICAgICAkeyhBcnJheS5pc0FycmF5KGFyZWEuZmFjdG9ycykgPyBhcmVhLmZhY3RvcnMgOiBbXSkubWFwKChmOiB7IG5hbWU6IHN0cmluZzsgdmFsdWU6IHN0cmluZyB9KSA9PiBgPGxpPuKAoiAke2YubmFtZX06ICR7Zi52YWx1ZX08L2xpPmApLmpvaW4oJycpfVxuICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgYCwge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdjdXN0b20tcG9wdXAnLFxuICAgICAgICAgICAgICBjbG9zZUJ1dHRvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgYXV0b1BhbjogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hZGRUbyhsYXllcnMuZmlyZVJpc2spO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZpcmUgcmlzayBkYXRhIGZvcm1hdCcpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyByaXNrIGFyZWFzOicsIGVycm9yKTtcbiAgfVxufTtcblxuICAgIC8vIEdldCBjb2xvciBiYXNlZCBvbiByaXNrIGxldmVsXG4gICAgY29uc3QgZ2V0Umlza0NvbG9yID0gKHJpc2tMZXZlbDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICAgIHN3aXRjaCAocmlza0xldmVsLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnZXh0cmVtZSc6IHJldHVybiAnI2ZmMDAwMCc7XG4gICAgICAgIGNhc2UgJ2hpZ2gnOiByZXR1cm4gJyNmZjY2MDAnO1xuICAgICAgICBjYXNlICdtb2RlcmF0ZSc6IHJldHVybiAnI2ZmY2MwMCc7XG4gICAgICAgIGNhc2UgJ2xvdyc6IHJldHVybiAnIzAwY2MwMCc7XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiAnIzAwZmYwMCc7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlyZVJpc2tMYXllcicpPy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZTogRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICBpZiAodGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgICAgbWFwLmFkZExheWVyKGxheWVycy5maXJlUmlzayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXAucmVtb3ZlTGF5ZXIobGF5ZXJzLmZpcmVSaXNrKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdldmFjdWF0aW9uUm91dGVzJyk/LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlOiBFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgIGlmICh0YXJnZXQuY2hlY2tlZCkge1xuICAgICAgICBtYXAuYWRkTGF5ZXIobGF5ZXJzLmV2YWN1YXRpb25Sb3V0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwLnJlbW92ZUxheWVyKGxheWVycy5ldmFjdWF0aW9uUm91dGVzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaXJlU3RhdGlvbnMnKT8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGU6IEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgaWYgKHRhcmdldC5jaGVja2VkKSB7XG4gICAgICAgIG1hcC5hZGRMYXllcihsYXllcnMuZmlyZVN0YXRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcC5yZW1vdmVMYXllcihsYXllcnMuZmlyZVN0YXRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3YXRlclNvdXJjZXMnKT8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGU6IEV2ZW50KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgaWYgKHRhcmdldC5jaGVja2VkKSB7XG4gICAgICAgIG1hcC5hZGRMYXllcihsYXllcnMud2F0ZXJTb3VyY2VzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcC5yZW1vdmVMYXllcihsYXllcnMud2F0ZXJTb3VyY2VzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aW1lUmFuZ2UnKT8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCk6IHZvaWQgPT4ge1xuICAgICAgdm9pZCB1cGRhdGVSaXNrQXJlYXMoKTtcbiAgICB9KTtcblxuICAgIC8vIExvYWQgaW5pdGlhbCBkYXRhXG4gICAgdm9pZCBsb2FkTWFwRGF0YSgpO1xuXG4gICAgLy8gQ2xlYW51cFxuICAgIHJldHVybiAoKTogdm9pZCA9PiB7XG4gICAgICBtYXAucmVtb3ZlKCk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIHJlbGF0aXZlXCI+XG4gICAgICA8ZGl2IGlkPVwibWFwXCIgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCByb3VuZGVkLWxnIG92ZXJmbG93LWhpZGRlbiBzaGFkb3ctbGdcIiAvPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtNCByaWdodC00IHotWzEwMDBdXCI+XG4gICAgICAgIDxNYXBMYXllcnMgLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbIl9zIiwiJFJlZnJlc2hTaWckIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiTWFwTGF5ZXJzIiwianN4IiwiX2pzeCIsImpzeHMiLCJfanN4cyIsIkxlYWZsZXRNYXAiLCJtYXBSZWYiLCJsYXllcnNSZWYiLCJkb2N1bWVudCIsIndpbmRvdyIsIkwiLCJjb25zb2xlIiwiZXJyb3IiLCJtYXAiLCJzZXRWaWV3IiwiY3VycmVudCIsInRpbGVMYXllciIsImF0dHJpYnV0aW9uIiwiYWRkVG8iLCJsYXllcnMiLCJmaXJlUmlzayIsImxheWVyR3JvdXAiLCJldmFjdWF0aW9uUm91dGVzIiwiZmlyZVN0YXRpb25zIiwid2F0ZXJTb3VyY2VzIiwiaWNvbnMiLCJmaXJlU3RhdGlvbiIsImljb24iLCJpY29uVXJsIiwiaWNvblNpemUiLCJpY29uQW5jaG9yIiwicG9wdXBBbmNob3IiLCJ3YXRlclNvdXJjZSIsImxvYWRNYXBEYXRhIiwicmVzcG9uc2UiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwRGF0YSIsImZvckVhY2giLCJzdGF0aW9uIiwiY29vcmRzIiwibGVuZ3RoIiwibmFtZSIsIm1hcmtlciIsImJpbmRQb3B1cCIsInNvdXJjZSIsInJvdXRlIiwicGF0aCIsInBvbHlsaW5lIiwiY29sb3IiLCJ3ZWlnaHQiLCJvcGFjaXR5IiwidXBkYXRlUmlza0FyZWFzIiwiRXJyb3IiLCJ0aW1lUmFuZ2UiLCJnZXRFbGVtZW50QnlJZCIsInZhbHVlIiwiY2xlYXJMYXllcnMiLCJ3ZWF0aGVyUmVzcG9uc2UiLCJjdXJyZW50V2VhdGhlclJhdyIsImN1cnJlbnRXZWF0aGVyIiwid2luZFNwZWVkIiwid2luZERpcmVjdGlvbiIsImh1bWlkaXR5IiwidGVtcGVyYXR1cmUiLCJyaXNrQXJlYXMiLCJmaXJlUmlza0RhdGEiLCJhcmVhIiwic2V2ZXJpdHkiLCJyaXNrTGV2ZWwiLCJmYWN0b3JzIiwiZ2V0Umlza0NvbG9yIiwicmFkaXVzIiwiY2lyY2xlIiwiZmlsbENvbG9yIiwiZmlsbE9wYWNpdHkiLCJTdHJpbmciLCJmIiwiam9pbiIsImNsYXNzTmFtZSIsImNsb3NlQnV0dG9uIiwiYXV0b1BhbiIsInRvTG93ZXJDYXNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJ0YXJnZXQiLCJjaGVja2VkIiwiYWRkTGF5ZXIiLCJyZW1vdmVMYXllciIsInJlbW92ZSIsImNoaWxkcmVuIiwiaWQiLCJfYyIsIiRSZWZyZXNoUmVnJCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/LeafletMap.tsx\n"));

/***/ })

}]);