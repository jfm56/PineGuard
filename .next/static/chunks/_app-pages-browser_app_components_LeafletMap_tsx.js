"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_app_components_LeafletMap_tsx"],{

/***/ "(app-pages-browser)/./app/components/LeafletMap.tsx":
/*!***************************************!*\
  !*** ./app/components/LeafletMap.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ LeafletMap; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _MapLayers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MapLayers */ \"(app-pages-browser)/./app/components/MapLayers.tsx\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ var _s = $RefreshSig$();\nvar _s1 = $RefreshSig$();\n\n\n\nfunction LeafletMap() {\n    _s();\n    _s1();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const layersRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        fireRisk: null,\n        evacuationRoutes: null,\n        fireStations: null,\n        waterSources: null,\n        weather: null\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var // Add event listeners\n        _document_getElementById, _document_getElementById1, _document_getElementById2, _document_getElementById3, _document_getElementById4, // Add weather layer toggle\n        _document_getElementById5;\n        // Wait for Leaflet to be available\n        if ( false || !window.L) {\n            console.error(\"Leaflet not loaded\");\n            return;\n        }\n        // Initialize map\n        const map = window.L.map(\"map\").setView([\n            39.8,\n            -74.5\n        ], 9);\n        mapRef.current = map;\n        // Add OpenStreetMap tiles\n        window.L.tileLayer(\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\", {\n            attribution: \"\\xa9 OpenStreetMap contributors\"\n        }).addTo(map);\n        // Initialize layer groups\n        const layers = {\n            fireRisk: window.L.layerGroup().addTo(map),\n            evacuationRoutes: window.L.layerGroup(),\n            fireStations: window.L.layerGroup(),\n            waterSources: window.L.layerGroup(),\n            weather: window.L.layerGroup().addTo(map)\n        };\n        layersRef.current = layers;\n        // Initialize icons\n        const icons = {\n            fireStation: window.L.icon({\n                iconUrl: \"/static/icons/fire-station.png\",\n                iconSize: [\n                    32,\n                    32\n                ],\n                iconAnchor: [\n                    16,\n                    32\n                ],\n                popupAnchor: [\n                    0,\n                    -32\n                ]\n            }),\n            waterSource: window.L.icon({\n                iconUrl: \"/static/icons/water-source.png\",\n                iconSize: [\n                    32,\n                    32\n                ],\n                iconAnchor: [\n                    16,\n                    32\n                ],\n                popupAnchor: [\n                    0,\n                    -32\n                ]\n            })\n        };\n        // Load initial map data\n        const loadMapData = async ()=>{\n            try {\n                const response = await fetch(\"/api/map-data\");\n                const data = await response.json();\n                // Add fire stations\n                data.fireStations.forEach((station)=>{\n                    window.L.marker(station.coords, {\n                        icon: icons.fireStation\n                    }).bindPopup(\"<b>\".concat(station.name, \"</b>\")).addTo(layers.fireStations);\n                });\n                // Add water sources\n                data.waterSources.forEach((source)=>{\n                    window.L.marker(source.coords, {\n                        icon: icons.waterSource\n                    }).bindPopup(\"<b>\".concat(source.name, \"</b>\")).addTo(layers.waterSources);\n                });\n                // Add evacuation routes\n                data.evacuationRoutes.forEach((route)=>{\n                    window.L.polyline(route.path, {\n                        color: \"blue\",\n                        weight: 3,\n                        opacity: 0.7\n                    }).bindPopup(\"<b>\".concat(route.name, \"</b>\")).addTo(layers.evacuationRoutes);\n                });\n                // Initial risk areas update\n                updateRiskAreas();\n            } catch (error) {\n                console.error(\"Error loading map data:\", error);\n            }\n        };\n        // Update weather overlay\n        const updateWeatherOverlay = async ()=>{\n            try {\n                const response = await fetch(\"/api/current-weather\");\n                const data = await response.json();\n                layers.weather.clearLayers();\n                // Add weather marker\n                const weatherIcon = window.L.divIcon({\n                    html: '\\n            <div class=\"bg-white/90 p-2 rounded-lg shadow-lg text-sm\">\\n              <div class=\"font-bold\">'.concat(data.temperature, \"\\xb0F</div>\\n              <div>\").concat(data.description, \"</div>\\n              <div>\").concat(data.windSpeed, \" mph \").concat(data.windDirection, \"</div>\\n            </div>\\n          \"),\n                    className: \"weather-icon\",\n                    iconSize: [\n                        100,\n                        80\n                    ]\n                });\n                window.L.marker([\n                    39.8,\n                    -74.5\n                ], {\n                    icon: weatherIcon\n                }).addTo(layers.weather);\n                // Update risk areas with weather data\n                updateRiskAreas();\n            } catch (error) {\n                console.error(\"Error updating weather:\", error);\n            }\n        };\n        // Update risk areas\n        const updateRiskAreas = async ()=>{\n            try {\n                var _document_getElementById;\n                const timeRange = ((_document_getElementById = document.getElementById(\"timeRange\")) === null || _document_getElementById === void 0 ? void 0 : _document_getElementById.value) || \"24h\";\n                layers.fireRisk.clearLayers();\n                const response = await fetch(\"/api/fire-risk?timeRange=\".concat(timeRange));\n                const data = await response.json();\n                // Adjust risk levels based on weather\n                // Get current weather data first\n                const weatherResponse = await fetch(\"/api/current-weather\");\n                const currentWeather = await weatherResponse.json();\n                data.riskAreas.forEach((area)=>{\n                    // Use current weather data to update risk levels\n                    const windSpeed = currentWeather.windSpeed;\n                    const humidity = currentWeather.humidity;\n                    // Update area's weather factors\n                    area.factors = [\n                        {\n                            name: \"Temperature\",\n                            value: \"\".concat(currentWeather.temperature, \"\\xb0F\")\n                        },\n                        {\n                            name: \"Wind Speed\",\n                            value: \"\".concat(windSpeed, \" mph \").concat(currentWeather.windDirection)\n                        },\n                        {\n                            name: \"Humidity\",\n                            value: \"\".concat(humidity, \"%\")\n                        }\n                    ];\n                    // Adjust risk level based on current conditions\n                    if (humidity < 30 && windSpeed > 15) {\n                        area.riskLevel = \"extreme\";\n                    } else if (humidity < 40 && windSpeed > 10) {\n                        area.riskLevel = \"high\";\n                    } else if (humidity > 60 && currentWeather.temperature < 50) {\n                        area.riskLevel = \"low\";\n                    }\n                    const color = getRiskColor(area.riskLevel);\n                    const radius = area.severity * 1000; // Convert to meters\n                    window.L.circle(area.coords, {\n                        color: color,\n                        fillColor: color,\n                        fillOpacity: 0.4,\n                        radius: radius\n                    }).bindPopup('\\n              <div class=\"p-2\">\\n                <div class=\"font-bold text-lg mb-2 capitalize\">Risk Level: '.concat(area.riskLevel, '</div>\\n                <div class=\"font-bold mt-2\">Current Conditions:</div>\\n                <ul class=\"mt-1\">\\n                  ').concat(area.factors.map((f)=>\"<li>â€¢ \".concat(f.name, \": \").concat(f.value, \"</li>\")).join(\"\"), \"\\n                </ul>\\n              </div>\\n            \"), {\n                        className: \"custom-popup\",\n                        closeButton: true,\n                        autoPan: true\n                    }).addTo(layers.fireRisk);\n                });\n            } catch (error) {\n                console.error(\"Error updating risk areas:\", error);\n            }\n        };\n        // Get color based on risk level\n        const getRiskColor = (riskLevel)=>{\n            switch(riskLevel.toLowerCase()){\n                case \"extreme\":\n                    return \"#ff0000\";\n                case \"high\":\n                    return \"#ff6600\";\n                case \"moderate\":\n                    return \"#ffcc00\";\n                case \"low\":\n                    return \"#00cc00\";\n                default:\n                    return \"#00ff00\";\n            }\n        };\n        (_document_getElementById = document.getElementById(\"fireRiskLayer\")) === null || _document_getElementById === void 0 ? void 0 : _document_getElementById.addEventListener(\"change\", (e)=>{\n            const target = e.target;\n            if (target.checked) {\n                map.addLayer(layers.fireRisk);\n            } else {\n                map.removeLayer(layers.fireRisk);\n            }\n        });\n        (_document_getElementById1 = document.getElementById(\"evacuationRoutes\")) === null || _document_getElementById1 === void 0 ? void 0 : _document_getElementById1.addEventListener(\"change\", (e)=>{\n            const target = e.target;\n            if (target.checked) {\n                map.addLayer(layers.evacuationRoutes);\n            } else {\n                map.removeLayer(layers.evacuationRoutes);\n            }\n        });\n        (_document_getElementById2 = document.getElementById(\"fireStations\")) === null || _document_getElementById2 === void 0 ? void 0 : _document_getElementById2.addEventListener(\"change\", (e)=>{\n            const target = e.target;\n            if (target.checked) {\n                map.addLayer(layers.fireStations);\n            } else {\n                map.removeLayer(layers.fireStations);\n            }\n        });\n        (_document_getElementById3 = document.getElementById(\"waterSources\")) === null || _document_getElementById3 === void 0 ? void 0 : _document_getElementById3.addEventListener(\"change\", (e)=>{\n            const target = e.target;\n            if (target.checked) {\n                map.addLayer(layers.waterSources);\n            } else {\n                map.removeLayer(layers.waterSources);\n            }\n        });\n        (_document_getElementById4 = document.getElementById(\"timeRange\")) === null || _document_getElementById4 === void 0 ? void 0 : _document_getElementById4.addEventListener(\"change\", ()=>{\n            updateRiskAreas();\n        });\n        // Load initial data and start weather updates\n        loadMapData();\n        updateWeatherOverlay();\n        // Update weather every 5 minutes\n        const weatherInterval = setInterval(updateWeatherOverlay, 5 * 60 * 1000);\n        (_document_getElementById5 = document.getElementById(\"weatherLayer\")) === null || _document_getElementById5 === void 0 ? void 0 : _document_getElementById5.addEventListener(\"change\", (e)=>{\n            const target = e.target;\n            if (target.checked) {\n                map.addLayer(layers.weather);\n            } else {\n                map.removeLayer(layers.weather);\n            }\n        });\n        // Cleanup\n        return ()=>{\n            clearInterval(weatherInterval);\n            map.remove();\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", {\n        className: \"w-full h-full relative\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n                id: \"map\",\n                className: \"w-full h-full rounded-lg overflow-hidden shadow-lg\"\n            }),\n            /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n                className: \"absolute top-4 right-4 z-[1000]\",\n                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_MapLayers__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {})\n            })\n        ]\n    });\n}\n_s(LeafletMap, \"vWzsBvb7Xyp21ifmTUtqwqJ9O2s=\");\n_c1 = LeafletMap;\n_s1(LeafletMap, \"vWzsBvb7Xyp21ifmTUtqwqJ9O2s=\");\n_c = LeafletMap;\nvar _c;\n$RefreshReg$(_c, \"LeafletMap\");\nvar _c1;\n$RefreshReg$(_c1, \"LeafletMap\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9jb21wb25lbnRzL0xlYWZsZXRNYXAudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFhLElBQUFBLE1BQUFDO0FBRTRCO0FBQ047QUFBQztBQVFyQixTQUFTUTs7SUFBMEJUO0lBQ2hELE1BQU1VLFNBQVNQLDZDQUFNQSxDQUFNO0lBQzNCLE1BQU1RLFlBQVlSLDZDQUFNQSxDQU1yQjtRQUFFUyxVQUFVO1FBQU1DLGtCQUFrQjtRQUFNQyxjQUFjO1FBQU1DLGNBQWM7UUFBTUMsU0FBUztJQUFLO0lBRW5HZCxnREFBU0EsQ0FBQztZQXlMUjtRQUNBZSwwQkFTQUEsMkJBU0FBLDJCQVNBQSwyQkFTQUEsMkJBV0E7UUFDQUE7UUF6T0E7UUFDQSxJQUFJLFVBQWlDLENBQUNDLE9BQU9DLENBQUMsRUFBRTtZQUM5Q0MsUUFBUUMsS0FBSyxDQUFDO1lBQ2Q7UUFDRjtRQUVBO1FBQ0EsTUFBTUMsTUFBTUosT0FBT0MsQ0FBQyxDQUFDRyxHQUFHLENBQUMsT0FBT0MsT0FBTyxDQUFDO1lBQUM7WUFBTSxDQUFDO1NBQUssRUFBRTtRQUN2RGIsT0FBT2MsT0FBTyxHQUFHRjtRQUVqQjtRQUNBSixPQUFPQyxDQUFDLENBQUNNLFNBQVMsQ0FBQyxzREFBc0Q7WUFDdkVDLGFBQWE7UUFDZixHQUFHQyxLQUFLLENBQUNMO1FBRVQ7UUFDQSxNQUFNTSxTQUFTO1lBQ2JoQixVQUFVTSxPQUFPQyxDQUFDLENBQUNVLFVBQVUsR0FBR0YsS0FBSyxDQUFDTDtZQUN0Q1Qsa0JBQWtCSyxPQUFPQyxDQUFDLENBQUNVLFVBQVU7WUFDckNmLGNBQWNJLE9BQU9DLENBQUMsQ0FBQ1UsVUFBVTtZQUNqQ2QsY0FBY0csT0FBT0MsQ0FBQyxDQUFDVSxVQUFVO1lBQ2pDYixTQUFTRSxPQUFPQyxDQUFDLENBQUNVLFVBQVUsR0FBR0YsS0FBSyxDQUFDTDtRQUN2QztRQUNBWCxVQUFVYSxPQUFPLEdBQUdJO1FBRXBCO1FBQ0EsTUFBTUUsUUFBUTtZQUNaQyxhQUFhYixPQUFPQyxDQUFDLENBQUNhLElBQUksQ0FBQztnQkFDekJDLFNBQVM7Z0JBQ1RDLFVBQVU7b0JBQUM7b0JBQUk7aUJBQUc7Z0JBQ2xCQyxZQUFZO29CQUFDO29CQUFJO2lCQUFHO2dCQUNwQkMsYUFBYTtvQkFBQztvQkFBRyxDQUFDO2lCQUFFO1lBQ3RCO1lBQ0FDLGFBQWFuQixPQUFPQyxDQUFDLENBQUNhLElBQUksQ0FBQztnQkFDekJDLFNBQVM7Z0JBQ1RDLFVBQVU7b0JBQUM7b0JBQUk7aUJBQUc7Z0JBQ2xCQyxZQUFZO29CQUFDO29CQUFJO2lCQUFHO2dCQUNwQkMsYUFBYTtvQkFBQztvQkFBRyxDQUFDO2lCQUFFO1lBQ3RCO1FBQ0Y7UUFFQTtRQUNBLE1BQU1FLGNBQWM7WUFDbEIsSUFBSTtnQkFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU07Z0JBQzdCLE1BQU1DLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtnQkFFaEM7Z0JBQ0FELEtBQUszQixZQUFZLENBQUM2QixPQUFPLENBQUVDLENBQUFBO29CQUN6QjFCLE9BQU9DLENBQUMsQ0FBQzBCLE1BQU0sQ0FBQ0QsUUFBUUUsTUFBTSxFQUFFO3dCQUFFZCxNQUFNRixNQUFNQyxXQUFBQTtvQkFBWSxHQUN2RGdCLFNBQVMsQ0FBRSxNQUFrQixPQUFiSCxRQUFRSSxJQUFLLFdBQzdCckIsS0FBSyxDQUFDQyxPQUFPZCxZQUFZO2dCQUM5QjtnQkFFQTtnQkFDQTJCLEtBQUsxQixZQUFZLENBQUM0QixPQUFPLENBQUVNLENBQUFBO29CQUN6Qi9CLE9BQU9DLENBQUMsQ0FBQzBCLE1BQU0sQ0FBQ0ksT0FBT0gsTUFBTSxFQUFFO3dCQUFFZCxNQUFNRixNQUFNTyxXQUFBQTtvQkFBWSxHQUN0RFUsU0FBUyxDQUFFLE1BQWlCLE9BQVpFLE9BQU9ELElBQUssV0FDNUJyQixLQUFLLENBQUNDLE9BQU9iLFlBQVk7Z0JBQzlCO2dCQUVBO2dCQUNBMEIsS0FBSzVCLGdCQUFnQixDQUFDOEIsT0FBTyxDQUFFTyxDQUFBQTtvQkFDN0JoQyxPQUFPQyxDQUFDLENBQUNnQyxRQUFRLENBQUNELE1BQU1FLElBQUksRUFBRTt3QkFDNUJDLE9BQU87d0JBQ1BDLFFBQVE7d0JBQ1JDLFNBQVM7b0JBQ1gsR0FDR1IsU0FBUyxDQUFFLE1BQWdCLE9BQVhHLE1BQU1GLElBQUssV0FDM0JyQixLQUFLLENBQUNDLE9BQU9mLGdCQUFnQjtnQkFDbEM7Z0JBRUE7Z0JBQ0EyQztZQUNGLEVBQUUsT0FBT25DLE9BQU87Z0JBQ2RELFFBQVFDLEtBQUssQ0FBQywyQkFBMkJBO1lBQzNDO1FBQ0Y7UUFFQTtRQUNBLE1BQU1vQyx1QkFBdUI7WUFDM0IsSUFBSTtnQkFDRixNQUFNbEIsV0FBVyxNQUFNQyxNQUFNO2dCQUM3QixNQUFNQyxPQUFPLE1BQU1GLFNBQVNHLElBQUk7Z0JBRWhDZCxPQUFPWixPQUFPLENBQUMwQyxXQUFXO2dCQUUxQjtnQkFDQSxNQUFNQyxjQUFjekMsT0FBT0MsQ0FBQyxDQUFDeUMsT0FBTyxDQUFDO29CQUNuQ0MsTUFBTyxrSEFHSXBCLE9BRGtCQSxLQUFLcUIsV0FBWSxzQ0FFbkNyQixPQURBQSxLQUFLc0IsV0FBWSxpQ0FDS3RCLE9BQXRCQSxLQUFLdUIsU0FBVSxXQUEwQixPQUFuQnZCLEtBQUt3QixhQUFjO29CQUdwREMsV0FBVztvQkFDWGhDLFVBQVU7d0JBQUM7d0JBQUs7cUJBQUU7Z0JBQ3BCO2dCQUVBaEIsT0FBT0MsQ0FBQyxDQUFDMEIsTUFBTSxDQUFDO29CQUFDO29CQUFNLENBQUM7aUJBQUssRUFBRTtvQkFBRWIsTUFBTTJCO2dCQUFZLEdBQ2hEaEMsS0FBSyxDQUFDQyxPQUFPWixPQUFPO2dCQUV2QjtnQkFDQXdDO1lBQ0YsRUFBRSxPQUFPbkMsT0FBTztnQkFDZEQsUUFBUUMsS0FBSyxDQUFDLDJCQUEyQkE7WUFDM0M7UUFDRjtRQUVBO1FBQ0EsTUFBTW1DLGtCQUFrQjtZQUN0QixJQUFJO29CQUNpQnZDO2dCQUFuQixNQUFNa0QsWUFBYWxELEVBQUFBLDJCQUFBQSxTQUFTbUQsY0FBYyxDQUFDLDBCQUF4Qm5ELCtDQUFBQSx5QkFBNERvRCxLQUFLLEtBQUk7Z0JBQ3hGekMsT0FBT2hCLFFBQVEsQ0FBQzhDLFdBQVc7Z0JBRTNCLE1BQU1uQixXQUFXLE1BQU1DLE1BQU8sNEJBQXFDLE9BQVYyQjtnQkFDekQsTUFBTTFCLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtnQkFFaEM7Z0JBQ0E7Z0JBQ0EsTUFBTTRCLGtCQUFrQixNQUFNOUIsTUFBTTtnQkFDcEMsTUFBTStCLGlCQUFpQixNQUFNRCxnQkFBZ0I1QixJQUFJO2dCQUVqREQsS0FBSytCLFNBQVMsQ0FBQzdCLE9BQU8sQ0FBRThCLENBQUFBO29CQUN0QjtvQkFDQSxNQUFNVCxZQUFZTyxlQUFlUCxTQUFTO29CQUMxQyxNQUFNVSxXQUFXSCxlQUFlRyxRQUFRO29CQUV4QztvQkFDQUQsS0FBS0UsT0FBTyxHQUFHO3dCQUNiOzRCQUFFM0IsTUFBTTs0QkFBZXFCLE9BQVEsR0FBNkIsT0FBM0JFLGVBQWVULFdBQVk7d0JBQUk7d0JBQ2hFOzRCQUFFZCxNQUFNOzRCQUFjcUIsT0FBUSxHQUFtQkUsT0FBakJQLFdBQVUsU0FBb0MsT0FBN0JPLGVBQWVOLGFBQWM7d0JBQUU7d0JBQ2hGOzRCQUFFakIsTUFBTTs0QkFBWXFCLE9BQVEsR0FBVyxPQUFUSyxVQUFTO3dCQUFHO3FCQUMzQztvQkFFRDtvQkFDQSxJQUFJQSxXQUFXLE1BQU1WLFlBQVksSUFBSTt3QkFDbkNTLEtBQUtHLFNBQVMsR0FBRztvQkFDbkIsT0FBTyxJQUFJRixXQUFXLE1BQU1WLFlBQVksSUFBSTt3QkFDMUNTLEtBQUtHLFNBQVMsR0FBRztvQkFDbkIsT0FBTyxJQUFJRixXQUFXLE1BQU1ILGVBQWVULFdBQVcsR0FBRyxJQUFJO3dCQUMzRFcsS0FBS0csU0FBUyxHQUFHO29CQUNuQjtvQkFDQSxNQUFNdkIsUUFBUXdCLGFBQWFKLEtBQUtHLFNBQVM7b0JBQ3pDLE1BQU1FLFNBQVNMLEtBQUtNLFFBQVEsR0FBRyxNQUFNO29CQUVyQzdELE9BQU9DLENBQUMsQ0FBQzZELE1BQU0sQ0FBQ1AsS0FBSzNCLE1BQU0sRUFBRTt3QkFDM0JPLE9BQU9BO3dCQUNQNEIsV0FBVzVCO3dCQUNYNkIsYUFBYTt3QkFDYkosUUFBUUE7b0JBQ1YsR0FDRy9CLFNBQVMsQ0FBRSxpSEFLSjBCLE9BSHlEQSxLQUFLRyxTQUFVLDBJQUdFLE9BQTFFSCxLQUFLRSxPQUFPLENBQUNyRCxHQUFHLENBQUU2RCxDQUFBQSxJQUFZLFNBQW1CQSxPQUFYQSxFQUFFbkMsSUFBSyxRQUFZLE9BQVJtQyxFQUFFZCxLQUFNLFlBQVFlLElBQUksQ0FBQyxLQUFJLGdFQUcvRTt3QkFDRGxCLFdBQVc7d0JBQ1htQixhQUFhO3dCQUNiQyxTQUFTO29CQUNYLEdBQ0MzRCxLQUFLLENBQUNDLE9BQU9oQixRQUFRO2dCQUMxQjtZQUNGLEVBQUUsT0FBT1MsT0FBTztnQkFDZEQsUUFBUUMsS0FBSyxDQUFDLDhCQUE4QkE7WUFDOUM7UUFDRjtRQUVBO1FBQ0EsTUFBTXdELGVBQWdCRCxDQUFBQTtZQUNwQixPQUFRQSxVQUFVVyxXQUFXO2dCQUMzQixLQUFLO29CQUFXLE9BQU87Z0JBQ3ZCLEtBQUs7b0JBQVEsT0FBTztnQkFDcEIsS0FBSztvQkFBWSxPQUFPO2dCQUN4QixLQUFLO29CQUFPLE9BQU87Z0JBQ25CO29CQUFTLE9BQU87WUFDbEI7UUFDRjtTQUdBdEUsMkJBQUFBLFNBQVNtRCxjQUFjLENBQUMsOEJBQXhCbkQsK0NBQUFBLHlCQUEwQ3VFLGdCQUFnQixDQUFDLFVBQVdDLENBQUFBO1lBQ3BFLE1BQU1DLFNBQVNELEVBQUVDLE1BQTBCO1lBQzNDLElBQUlBLE9BQU9DLE9BQU8sRUFBRTtnQkFDbEJyRSxJQUFJc0UsUUFBUSxDQUFDaEUsT0FBT2hCLFFBQVE7WUFDOUIsT0FBTztnQkFDTFUsSUFBSXVFLFdBQVcsQ0FBQ2pFLE9BQU9oQixRQUFRO1lBQ2pDO1FBQ0Y7U0FFQUssNEJBQUFBLFNBQVNtRCxjQUFjLENBQUMsaUNBQXhCbkQsZ0RBQUFBLDBCQUE2Q3VFLGdCQUFnQixDQUFDLFVBQVdDLENBQUFBO1lBQ3ZFLE1BQU1DLFNBQVNELEVBQUVDLE1BQTBCO1lBQzNDLElBQUlBLE9BQU9DLE9BQU8sRUFBRTtnQkFDbEJyRSxJQUFJc0UsUUFBUSxDQUFDaEUsT0FBT2YsZ0JBQWdCO1lBQ3RDLE9BQU87Z0JBQ0xTLElBQUl1RSxXQUFXLENBQUNqRSxPQUFPZixnQkFBZ0I7WUFDekM7UUFDRjtTQUVBSSw0QkFBQUEsU0FBU21ELGNBQWMsQ0FBQyw2QkFBeEJuRCxnREFBQUEsMEJBQXlDdUUsZ0JBQWdCLENBQUMsVUFBV0MsQ0FBQUE7WUFDbkUsTUFBTUMsU0FBU0QsRUFBRUMsTUFBMEI7WUFDM0MsSUFBSUEsT0FBT0MsT0FBTyxFQUFFO2dCQUNsQnJFLElBQUlzRSxRQUFRLENBQUNoRSxPQUFPZCxZQUFZO1lBQ2xDLE9BQU87Z0JBQ0xRLElBQUl1RSxXQUFXLENBQUNqRSxPQUFPZCxZQUFZO1lBQ3JDO1FBQ0Y7U0FFQUcsNEJBQUFBLFNBQVNtRCxjQUFjLENBQUMsNkJBQXhCbkQsZ0RBQUFBLDBCQUF5Q3VFLGdCQUFnQixDQUFDLFVBQVdDLENBQUFBO1lBQ25FLE1BQU1DLFNBQVNELEVBQUVDLE1BQTBCO1lBQzNDLElBQUlBLE9BQU9DLE9BQU8sRUFBRTtnQkFDbEJyRSxJQUFJc0UsUUFBUSxDQUFDaEUsT0FBT2IsWUFBWTtZQUNsQyxPQUFPO2dCQUNMTyxJQUFJdUUsV0FBVyxDQUFDakUsT0FBT2IsWUFBWTtZQUNyQztRQUNGO1NBRUFFLDRCQUFBQSxTQUFTbUQsY0FBYyxDQUFDLDBCQUF4Qm5ELGdEQUFBQSwwQkFBc0N1RSxnQkFBZ0IsQ0FBQyxVQUFVO1lBQy9EaEM7UUFDRjtRQUVBO1FBQ0FsQjtRQUNBbUI7UUFFQTtRQUNBLE1BQU1xQyxrQkFBa0JDLFlBQVl0QyxzQkFBc0IsSUFBSSxLQUFLO1NBR25FeEMsNEJBQUFBLFNBQVNtRCxjQUFjLENBQUMsNkJBQXhCbkQsZ0RBQUFBLDBCQUF5Q3VFLGdCQUFnQixDQUFDLFVBQVdDLENBQUFBO1lBQ25FLE1BQU1DLFNBQVNELEVBQUVDLE1BQTBCO1lBQzNDLElBQUlBLE9BQU9DLE9BQU8sRUFBRTtnQkFDbEJyRSxJQUFJc0UsUUFBUSxDQUFDaEUsT0FBT1osT0FBTztZQUM3QixPQUFPO2dCQUNMTSxJQUFJdUUsV0FBVyxDQUFDakUsT0FBT1osT0FBTztZQUNoQztRQUNGO1FBRUE7UUFDQSxPQUFPO1lBQ0xnRixjQUFjRjtZQUNkeEUsSUFBSTJFLE1BQU07UUFDWjtJQUNGLEdBQUcsRUFBRTtJQUVMLHFCQUNFekYsdURBQUFBLENBQUE7UUFBSzBELFdBQVU7UUFBd0JnQyxVQUFBO1lBQUEsY0FDckM1RixzREFBQUEsQ0FBQTtnQkFBSzZGLElBQUc7Z0JBQU1qQyxXQUFVO1lBQW9EO1lBQUcsY0FDL0U1RCxzREFBQUEsQ0FBQTtnQkFBSzRELFdBQVU7Z0JBQWlDZ0MsVUFBQSxjQUM5QzVGLHNEQUFBQSxDQUFDRixrREFBU0EsRUFBQTtZQUFHO1NBQ1Q7SUFBQTtBQUdaO0dBNVF3Qks7TUFBQUE7QUE0UXZCVCxJQTVRdUJTLFlBQVU7QUFBQTJGLEtBQVYzRjtBQUFVLElBQUEyRjtBQUFBQyxhQUFBRCxJQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9jb21wb25lbnRzL0xlYWZsZXRNYXAudHN4PzVmZTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBNYXBMYXllcnMgZnJvbSAnLi9NYXBMYXllcnMnO1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIEw6IGFueTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMZWFmbGV0TWFwKCk6IEpTWC5FbGVtZW50IHtcbiAgY29uc3QgbWFwUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XG4gIGNvbnN0IGxheWVyc1JlZiA9IHVzZVJlZjx7XG4gICAgZmlyZVJpc2s6IGFueTtcbiAgICBldmFjdWF0aW9uUm91dGVzOiBhbnk7XG4gICAgZmlyZVN0YXRpb25zOiBhbnk7XG4gICAgd2F0ZXJTb3VyY2VzOiBhbnk7XG4gICAgd2VhdGhlcjogYW55O1xuICB9Pih7IGZpcmVSaXNrOiBudWxsLCBldmFjdWF0aW9uUm91dGVzOiBudWxsLCBmaXJlU3RhdGlvbnM6IG51bGwsIHdhdGVyU291cmNlczogbnVsbCwgd2VhdGhlcjogbnVsbCB9KTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFdhaXQgZm9yIExlYWZsZXQgdG8gYmUgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cuTCkge1xuICAgICAgY29uc29sZS5lcnJvcignTGVhZmxldCBub3QgbG9hZGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBtYXBcbiAgICBjb25zdCBtYXAgPSB3aW5kb3cuTC5tYXAoJ21hcCcpLnNldFZpZXcoWzM5LjgsIC03NC41XSwgOSk7XG4gICAgbWFwUmVmLmN1cnJlbnQgPSBtYXA7XG5cbiAgICAvLyBBZGQgT3BlblN0cmVldE1hcCB0aWxlc1xuICAgIHdpbmRvdy5MLnRpbGVMYXllcignaHR0cHM6Ly97c30udGlsZS5vcGVuc3RyZWV0bWFwLm9yZy97en0ve3h9L3t5fS5wbmcnLCB7XG4gICAgICBhdHRyaWJ1dGlvbjogJ8KpIE9wZW5TdHJlZXRNYXAgY29udHJpYnV0b3JzJ1xuICAgIH0pLmFkZFRvKG1hcCk7XG5cbiAgICAvLyBJbml0aWFsaXplIGxheWVyIGdyb3Vwc1xuICAgIGNvbnN0IGxheWVycyA9IHtcbiAgICAgIGZpcmVSaXNrOiB3aW5kb3cuTC5sYXllckdyb3VwKCkuYWRkVG8obWFwKSxcbiAgICAgIGV2YWN1YXRpb25Sb3V0ZXM6IHdpbmRvdy5MLmxheWVyR3JvdXAoKSxcbiAgICAgIGZpcmVTdGF0aW9uczogd2luZG93LkwubGF5ZXJHcm91cCgpLFxuICAgICAgd2F0ZXJTb3VyY2VzOiB3aW5kb3cuTC5sYXllckdyb3VwKCksXG4gICAgICB3ZWF0aGVyOiB3aW5kb3cuTC5sYXllckdyb3VwKCkuYWRkVG8obWFwKVxuICAgIH07XG4gICAgbGF5ZXJzUmVmLmN1cnJlbnQgPSBsYXllcnM7XG5cbiAgICAvLyBJbml0aWFsaXplIGljb25zXG4gICAgY29uc3QgaWNvbnMgPSB7XG4gICAgICBmaXJlU3RhdGlvbjogd2luZG93LkwuaWNvbih7XG4gICAgICAgIGljb25Vcmw6ICcvc3RhdGljL2ljb25zL2ZpcmUtc3RhdGlvbi5wbmcnLFxuICAgICAgICBpY29uU2l6ZTogWzMyLCAzMl0sXG4gICAgICAgIGljb25BbmNob3I6IFsxNiwgMzJdLFxuICAgICAgICBwb3B1cEFuY2hvcjogWzAsIC0zMl1cbiAgICAgIH0pLFxuICAgICAgd2F0ZXJTb3VyY2U6IHdpbmRvdy5MLmljb24oe1xuICAgICAgICBpY29uVXJsOiAnL3N0YXRpYy9pY29ucy93YXRlci1zb3VyY2UucG5nJyxcbiAgICAgICAgaWNvblNpemU6IFszMiwgMzJdLFxuICAgICAgICBpY29uQW5jaG9yOiBbMTYsIDMyXSxcbiAgICAgICAgcG9wdXBBbmNob3I6IFswLCAtMzJdXG4gICAgICB9KVxuICAgIH07XG5cbiAgICAvLyBMb2FkIGluaXRpYWwgbWFwIGRhdGFcbiAgICBjb25zdCBsb2FkTWFwRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvbWFwLWRhdGEnKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICAvLyBBZGQgZmlyZSBzdGF0aW9uc1xuICAgICAgICBkYXRhLmZpcmVTdGF0aW9ucy5mb3JFYWNoKChzdGF0aW9uOiBhbnkpID0+IHtcbiAgICAgICAgICB3aW5kb3cuTC5tYXJrZXIoc3RhdGlvbi5jb29yZHMsIHsgaWNvbjogaWNvbnMuZmlyZVN0YXRpb24gfSlcbiAgICAgICAgICAgIC5iaW5kUG9wdXAoYDxiPiR7c3RhdGlvbi5uYW1lfTwvYj5gKVxuICAgICAgICAgICAgLmFkZFRvKGxheWVycy5maXJlU3RhdGlvbnMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgd2F0ZXIgc291cmNlc1xuICAgICAgICBkYXRhLndhdGVyU291cmNlcy5mb3JFYWNoKChzb3VyY2U6IGFueSkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5MLm1hcmtlcihzb3VyY2UuY29vcmRzLCB7IGljb246IGljb25zLndhdGVyU291cmNlIH0pXG4gICAgICAgICAgICAuYmluZFBvcHVwKGA8Yj4ke3NvdXJjZS5uYW1lfTwvYj5gKVxuICAgICAgICAgICAgLmFkZFRvKGxheWVycy53YXRlclNvdXJjZXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgZXZhY3VhdGlvbiByb3V0ZXNcbiAgICAgICAgZGF0YS5ldmFjdWF0aW9uUm91dGVzLmZvckVhY2goKHJvdXRlOiBhbnkpID0+IHtcbiAgICAgICAgICB3aW5kb3cuTC5wb2x5bGluZShyb3V0ZS5wYXRoLCB7XG4gICAgICAgICAgICBjb2xvcjogJ2JsdWUnLFxuICAgICAgICAgICAgd2VpZ2h0OiAzLFxuICAgICAgICAgICAgb3BhY2l0eTogMC43XG4gICAgICAgICAgfSlcbiAgICAgICAgICAgIC5iaW5kUG9wdXAoYDxiPiR7cm91dGUubmFtZX08L2I+YClcbiAgICAgICAgICAgIC5hZGRUbyhsYXllcnMuZXZhY3VhdGlvblJvdXRlcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEluaXRpYWwgcmlzayBhcmVhcyB1cGRhdGVcbiAgICAgICAgdXBkYXRlUmlza0FyZWFzKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIG1hcCBkYXRhOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVXBkYXRlIHdlYXRoZXIgb3ZlcmxheVxuICAgIGNvbnN0IHVwZGF0ZVdlYXRoZXJPdmVybGF5ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jdXJyZW50LXdlYXRoZXInKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgXG4gICAgICAgIGxheWVycy53ZWF0aGVyLmNsZWFyTGF5ZXJzKCk7XG5cbiAgICAgICAgLy8gQWRkIHdlYXRoZXIgbWFya2VyXG4gICAgICAgIGNvbnN0IHdlYXRoZXJJY29uID0gd2luZG93LkwuZGl2SWNvbih7XG4gICAgICAgICAgaHRtbDogYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJnLXdoaXRlLzkwIHAtMiByb3VuZGVkLWxnIHNoYWRvdy1sZyB0ZXh0LXNtXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb250LWJvbGRcIj4ke2RhdGEudGVtcGVyYXR1cmV9wrBGPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXY+JHtkYXRhLmRlc2NyaXB0aW9ufTwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2PiR7ZGF0YS53aW5kU3BlZWR9IG1waCAke2RhdGEud2luZERpcmVjdGlvbn08L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIGAsXG4gICAgICAgICAgY2xhc3NOYW1lOiAnd2VhdGhlci1pY29uJyxcbiAgICAgICAgICBpY29uU2l6ZTogWzEwMCwgODBdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdpbmRvdy5MLm1hcmtlcihbMzkuOCwgLTc0LjVdLCB7IGljb246IHdlYXRoZXJJY29uIH0pXG4gICAgICAgICAgLmFkZFRvKGxheWVycy53ZWF0aGVyKTtcblxuICAgICAgICAvLyBVcGRhdGUgcmlzayBhcmVhcyB3aXRoIHdlYXRoZXIgZGF0YVxuICAgICAgICB1cGRhdGVSaXNrQXJlYXMoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHdlYXRoZXI6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBVcGRhdGUgcmlzayBhcmVhc1xuICAgIGNvbnN0IHVwZGF0ZVJpc2tBcmVhcyA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRpbWVSYW5nZSA9IChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGltZVJhbmdlJykgYXMgSFRNTFNlbGVjdEVsZW1lbnQpPy52YWx1ZSB8fCAnMjRoJztcbiAgICAgICAgbGF5ZXJzLmZpcmVSaXNrLmNsZWFyTGF5ZXJzKCk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9maXJlLXJpc2s/dGltZVJhbmdlPSR7dGltZVJhbmdlfWApO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgIC8vIEFkanVzdCByaXNrIGxldmVscyBiYXNlZCBvbiB3ZWF0aGVyXG4gICAgICAgIC8vIEdldCBjdXJyZW50IHdlYXRoZXIgZGF0YSBmaXJzdFxuICAgICAgICBjb25zdCB3ZWF0aGVyUmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jdXJyZW50LXdlYXRoZXInKTtcbiAgICAgICAgY29uc3QgY3VycmVudFdlYXRoZXIgPSBhd2FpdCB3ZWF0aGVyUmVzcG9uc2UuanNvbigpO1xuICAgICAgICBcbiAgICAgICAgZGF0YS5yaXNrQXJlYXMuZm9yRWFjaCgoYXJlYTogYW55KSA9PiB7XG4gICAgICAgICAgLy8gVXNlIGN1cnJlbnQgd2VhdGhlciBkYXRhIHRvIHVwZGF0ZSByaXNrIGxldmVsc1xuICAgICAgICAgIGNvbnN0IHdpbmRTcGVlZCA9IGN1cnJlbnRXZWF0aGVyLndpbmRTcGVlZDtcbiAgICAgICAgICBjb25zdCBodW1pZGl0eSA9IGN1cnJlbnRXZWF0aGVyLmh1bWlkaXR5O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBhcmVhJ3Mgd2VhdGhlciBmYWN0b3JzXG4gICAgICAgICAgYXJlYS5mYWN0b3JzID0gW1xuICAgICAgICAgICAgeyBuYW1lOiAnVGVtcGVyYXR1cmUnLCB2YWx1ZTogYCR7Y3VycmVudFdlYXRoZXIudGVtcGVyYXR1cmV9wrBGYCB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnV2luZCBTcGVlZCcsIHZhbHVlOiBgJHt3aW5kU3BlZWR9IG1waCAke2N1cnJlbnRXZWF0aGVyLndpbmREaXJlY3Rpb259YCB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnSHVtaWRpdHknLCB2YWx1ZTogYCR7aHVtaWRpdHl9JWAgfVxuICAgICAgICAgIF07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWRqdXN0IHJpc2sgbGV2ZWwgYmFzZWQgb24gY3VycmVudCBjb25kaXRpb25zXG4gICAgICAgICAgaWYgKGh1bWlkaXR5IDwgMzAgJiYgd2luZFNwZWVkID4gMTUpIHtcbiAgICAgICAgICAgIGFyZWEucmlza0xldmVsID0gJ2V4dHJlbWUnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaHVtaWRpdHkgPCA0MCAmJiB3aW5kU3BlZWQgPiAxMCkge1xuICAgICAgICAgICAgYXJlYS5yaXNrTGV2ZWwgPSAnaGlnaCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChodW1pZGl0eSA+IDYwICYmIGN1cnJlbnRXZWF0aGVyLnRlbXBlcmF0dXJlIDwgNTApIHtcbiAgICAgICAgICAgIGFyZWEucmlza0xldmVsID0gJ2xvdyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Umlza0NvbG9yKGFyZWEucmlza0xldmVsKTtcbiAgICAgICAgICBjb25zdCByYWRpdXMgPSBhcmVhLnNldmVyaXR5ICogMTAwMDsgLy8gQ29udmVydCB0byBtZXRlcnNcblxuICAgICAgICAgIHdpbmRvdy5MLmNpcmNsZShhcmVhLmNvb3Jkcywge1xuICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgZmlsbENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwLjQsXG4gICAgICAgICAgICByYWRpdXM6IHJhZGl1c1xuICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYmluZFBvcHVwKGBcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInAtMlwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb250LWJvbGQgdGV4dC1sZyBtYi0yIGNhcGl0YWxpemVcIj5SaXNrIExldmVsOiAke2FyZWEucmlza0xldmVsfTwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb250LWJvbGQgbXQtMlwiPkN1cnJlbnQgQ29uZGl0aW9uczo8L2Rpdj5cbiAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJtdC0xXCI+XG4gICAgICAgICAgICAgICAgICAke2FyZWEuZmFjdG9ycy5tYXAoKGY6IGFueSkgPT4gYDxsaT7igKIgJHtmLm5hbWV9OiAke2YudmFsdWV9PC9saT5gKS5qb2luKCcnKX1cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIGAsIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnY3VzdG9tLXBvcHVwJyxcbiAgICAgICAgICAgICAgY2xvc2VCdXR0b246IHRydWUsXG4gICAgICAgICAgICAgIGF1dG9QYW46IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYWRkVG8obGF5ZXJzLmZpcmVSaXNrKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyByaXNrIGFyZWFzOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gR2V0IGNvbG9yIGJhc2VkIG9uIHJpc2sgbGV2ZWxcbiAgICBjb25zdCBnZXRSaXNrQ29sb3IgPSAocmlza0xldmVsOiBzdHJpbmcpID0+IHtcbiAgICAgIHN3aXRjaCAocmlza0xldmVsLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnZXh0cmVtZSc6IHJldHVybiAnI2ZmMDAwMCc7XG4gICAgICAgIGNhc2UgJ2hpZ2gnOiByZXR1cm4gJyNmZjY2MDAnO1xuICAgICAgICBjYXNlICdtb2RlcmF0ZSc6IHJldHVybiAnI2ZmY2MwMCc7XG4gICAgICAgIGNhc2UgJ2xvdyc6IHJldHVybiAnIzAwY2MwMCc7XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiAnIzAwZmYwMCc7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlyZVJpc2tMYXllcicpPy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgIGlmICh0YXJnZXQuY2hlY2tlZCkge1xuICAgICAgICBtYXAuYWRkTGF5ZXIobGF5ZXJzLmZpcmVSaXNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcC5yZW1vdmVMYXllcihsYXllcnMuZmlyZVJpc2spO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V2YWN1YXRpb25Sb3V0ZXMnKT8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICBpZiAodGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgICAgbWFwLmFkZExheWVyKGxheWVycy5ldmFjdWF0aW9uUm91dGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcC5yZW1vdmVMYXllcihsYXllcnMuZXZhY3VhdGlvblJvdXRlcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlyZVN0YXRpb25zJyk/LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgaWYgKHRhcmdldC5jaGVja2VkKSB7XG4gICAgICAgIG1hcC5hZGRMYXllcihsYXllcnMuZmlyZVN0YXRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcC5yZW1vdmVMYXllcihsYXllcnMuZmlyZVN0YXRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3YXRlclNvdXJjZXMnKT8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICBpZiAodGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgICAgbWFwLmFkZExheWVyKGxheWVycy53YXRlclNvdXJjZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwLnJlbW92ZUxheWVyKGxheWVycy53YXRlclNvdXJjZXMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RpbWVSYW5nZScpPy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICB1cGRhdGVSaXNrQXJlYXMoKTtcbiAgICB9KTtcblxuICAgIC8vIExvYWQgaW5pdGlhbCBkYXRhIGFuZCBzdGFydCB3ZWF0aGVyIHVwZGF0ZXNcbiAgICBsb2FkTWFwRGF0YSgpO1xuICAgIHVwZGF0ZVdlYXRoZXJPdmVybGF5KCk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHdlYXRoZXIgZXZlcnkgNSBtaW51dGVzXG4gICAgY29uc3Qgd2VhdGhlckludGVydmFsID0gc2V0SW50ZXJ2YWwodXBkYXRlV2VhdGhlck92ZXJsYXksIDUgKiA2MCAqIDEwMDApO1xuICAgIFxuICAgIC8vIEFkZCB3ZWF0aGVyIGxheWVyIHRvZ2dsZVxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3ZWF0aGVyTGF5ZXInKT8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICBpZiAodGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgICAgbWFwLmFkZExheWVyKGxheWVycy53ZWF0aGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcC5yZW1vdmVMYXllcihsYXllcnMud2VhdGhlcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDbGVhbnVwXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFySW50ZXJ2YWwod2VhdGhlckludGVydmFsKTtcbiAgICAgIG1hcC5yZW1vdmUoKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgcmVsYXRpdmVcIj5cbiAgICAgIDxkaXYgaWQ9XCJtYXBcIiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIHJvdW5kZWQtbGcgb3ZlcmZsb3ctaGlkZGVuIHNoYWRvdy1sZ1wiIC8+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIHRvcC00IHJpZ2h0LTQgei1bMTAwMF1cIj5cbiAgICAgICAgPE1hcExheWVycyAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiX3MiLCIkUmVmcmVzaFNpZyQiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJNYXBMYXllcnMiLCJqc3giLCJfanN4IiwianN4cyIsIl9qc3hzIiwiTGVhZmxldE1hcCIsIm1hcFJlZiIsImxheWVyc1JlZiIsImZpcmVSaXNrIiwiZXZhY3VhdGlvblJvdXRlcyIsImZpcmVTdGF0aW9ucyIsIndhdGVyU291cmNlcyIsIndlYXRoZXIiLCJkb2N1bWVudCIsIndpbmRvdyIsIkwiLCJjb25zb2xlIiwiZXJyb3IiLCJtYXAiLCJzZXRWaWV3IiwiY3VycmVudCIsInRpbGVMYXllciIsImF0dHJpYnV0aW9uIiwiYWRkVG8iLCJsYXllcnMiLCJsYXllckdyb3VwIiwiaWNvbnMiLCJmaXJlU3RhdGlvbiIsImljb24iLCJpY29uVXJsIiwiaWNvblNpemUiLCJpY29uQW5jaG9yIiwicG9wdXBBbmNob3IiLCJ3YXRlclNvdXJjZSIsImxvYWRNYXBEYXRhIiwicmVzcG9uc2UiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwiZm9yRWFjaCIsInN0YXRpb24iLCJtYXJrZXIiLCJjb29yZHMiLCJiaW5kUG9wdXAiLCJuYW1lIiwic291cmNlIiwicm91dGUiLCJwb2x5bGluZSIsInBhdGgiLCJjb2xvciIsIndlaWdodCIsIm9wYWNpdHkiLCJ1cGRhdGVSaXNrQXJlYXMiLCJ1cGRhdGVXZWF0aGVyT3ZlcmxheSIsImNsZWFyTGF5ZXJzIiwid2VhdGhlckljb24iLCJkaXZJY29uIiwiaHRtbCIsInRlbXBlcmF0dXJlIiwiZGVzY3JpcHRpb24iLCJ3aW5kU3BlZWQiLCJ3aW5kRGlyZWN0aW9uIiwiY2xhc3NOYW1lIiwidGltZVJhbmdlIiwiZ2V0RWxlbWVudEJ5SWQiLCJ2YWx1ZSIsIndlYXRoZXJSZXNwb25zZSIsImN1cnJlbnRXZWF0aGVyIiwicmlza0FyZWFzIiwiYXJlYSIsImh1bWlkaXR5IiwiZmFjdG9ycyIsInJpc2tMZXZlbCIsImdldFJpc2tDb2xvciIsInJhZGl1cyIsInNldmVyaXR5IiwiY2lyY2xlIiwiZmlsbENvbG9yIiwiZmlsbE9wYWNpdHkiLCJmIiwiam9pbiIsImNsb3NlQnV0dG9uIiwiYXV0b1BhbiIsInRvTG93ZXJDYXNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJ0YXJnZXQiLCJjaGVja2VkIiwiYWRkTGF5ZXIiLCJyZW1vdmVMYXllciIsIndlYXRoZXJJbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInJlbW92ZSIsImNoaWxkcmVuIiwiaWQiLCJfYyIsIiRSZWZyZXNoUmVnJCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/components/LeafletMap.tsx\n"));

/***/ })

}]);